\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\newcommand{\String}{\mathsf{String}}
\newcommand{\Real}{\ensuremath{\mathbb{R}}}
\newcommand{\Bool}{\ensuremath{\mathbb{B}}}

\hypersetup{
  bookmarks=true,     % show bookmarks bar?
  colorlinks=true,       % false: boxed links; true: colored links
  linkcolor=red,          % color of internal links (change box color
  % with linkbordercolor)
  citecolor=blue,      % color of links to bibliography
  filecolor=magenta,  % color of file links
  urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{4cm}p{2cm}X}
  \toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
  \midrule
  November 13, 2025 & 1.0 &  Rev-1 Design Document\\
  January 11, 2025 & 1.1 & Peer Review \texttt{\#239} Applied\\
  \bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \citet{SRS}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for the
\progname{} system, \textbf{Reading4All}. Reading4All is an
artificial intelligence (AI)/machine learning (ML) tool that
provides detailed and contextually aware alternative text for
complicated technical graphics, notably those found in postsecondary
Science, Technology, Engineering, and Mathematics (STEM) course materials.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/4G06-CAPSTONE-2025/Reading4All/}.

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname.

\begin{center}
  \renewcommand{\arraystretch}{1.2}
  \noindent
  \begin{tabular}{l l p{7.5cm}}
    \toprule
    \textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\
    \midrule
    character & char & a single symbol or digit\\
    integer & $\mathbb{Z}$ & a number without a fractional component
    in (-$\infty$, $\infty$) \\
    natural number & $\mathbb{N}$ & a number without a fractional
    component in [1, $\infty$) \\
    real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
    boolean & \Bool & True, False \\
    \bottomrule
  \end{tabular}
\end{center}

\noindent
The specification of \progname \ uses some derived data types:
sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document
for this project.
\begin{table}[h!]
  \centering
  \begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
    \toprule
    \textbf{Level 1} & \textbf{Level 2}\\
    \midrule

    {Hardware-Hiding Module} & N/A \\
    \midrule

    \multirow{13}{0.3\textwidth}{Behaviour-Hiding Module} &
    {DataPreprocess Module}\\ &
    {WCAGCompliance Module}\\ &
    {ModelOutput Module}\\ &
    {AuthenticationService Module}\\ &
    {SessionManagement Module}\\ &
    {BackendController Module}\\ &
    {Logging Module}\\ &
    {ImageValidation Module}\\ &
    {UserInterfaceInteractions Module} \\ &
    {MainScreen Module} \\ &
    {ShowHistoryScreen Module} \\ &
    {LogInScreen Module} \\ &
    {UserInterfaceAccessibility Module} \\
    \midrule

    \multirow{6}{0.3\textwidth}{Software Decision Module} &
    {AIModelTraining Module }\\ &
    {CaptionGeneration Module}\\ &
    {InternalMetricCompliance}\\ &
    {FeedbackMetrics Module}\\ &
    {FeedbackIntegration Module}\\ &
    {FeedbackLoop Module}\\
    \bottomrule
  \end{tabular}
  \caption{Module Hierarchy}
  \label{TblMH}
\end{table}

\newpage
~\newpage

%----------------------------------------------------------

\section{MIS of DataPreprocess Module} \label{datapp}

\subsection{Module}
\texttt{DataPP}

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{SUPPORTED\_IMAGE\_TYPES}: \texttt{List[String]} -- Accepted input formats (e.g., \{"PNG","JPEG"\}).\\
\texttt{TARGET\_WIDTH}: $\mathbb{N}$ -- Desired output width in pixels (may be hardcoded in early versions).\\
\texttt{TARGET\_HEIGHT}: $\mathbb{N}$ -- Desired output height in pixels (may be hardcoded in early versions).\\
\texttt{NORMALIZE\_MODE}: String -- Normalization scheme (e.g., \{"none","imagenet"\}); may be hardcoded.

\subsubsection{Exported Access Programs}
\begin{center}
  \begin{tabular}{p{2cm} p{4cm} p{6cm} p{4cm}}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  initialize & configPath:String & - & ConfigFileNotFoundException \\
  \hline
  filterInput & imageFilePath:String & PreprocessedImagePath:String & InvalidInputException \\
  \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\texttt{lastInputPath}: String -- (Optional) caches most recently processed input path for debugging/traceability.\\
\texttt{lastOutputPath}: String -- (Optional) caches most recently produced output path for debugging/traceability.

\subsubsection{Environment Variables}
\texttt{InputImage}: Image -- Image loaded from \texttt{imageFilePath} via the filesystem.\\
\texttt{OutputImage}: Image -- Processed image produced by this module and made available to downstream modules in the system.\\
\texttt{Filesystem} -- Used to read input images and write preprocessed outputs.\\
\texttt{ImageCodec} -- System/library support for decoding and encoding image formats.

\subsubsection{Assumptions}
\begin{itemize}
  \item \texttt{initialize} is called before \texttt{filterInput}.
  \item Constants may be hardcoded in the current implementation and moved to configuration later.
  \item State variables are optional; omitting them does not affect functional correctness.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent \textbf{initialize(configPath):}
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item Load preprocessing configuration parameters (image size, normalization mode)
    \item Initialize filesystem and image codec dependencies
  \end{itemize}
  \item output: None.
  \item exception: Raises \texttt{ConfigFileNotFoundException} if configuration cannot be loaded.
\end{itemize}

\noindent \textbf{filterInput(imageFilePath):}
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item (Optional) \texttt{lastInputPath} := imageFilePath
    \item Read \texttt{InputImage} from \texttt{Filesystem} using \texttt{ImageCodec}
    \item Verify that \texttt{InputImage} is readable and its format is in \texttt{SUPPORTED\_IMAGE\_TYPES}
    \item Transform \texttt{InputImage} by:
    \begin{itemize}
      \item resizing it to (\texttt{TARGET\_WIDTH}, \texttt{TARGET\_HEIGHT})
      \item applying pixel-value normalization according to \texttt{NORMALIZE\_MODE}
    \end{itemize}
    \item Assign the transformed image to \texttt{OutputImage}
    \item Make \texttt{OutputImage} available to downstream modules
    \item (Optional) update internal state to reflect successful preprocessing
  \end{itemize}
  \item output: Returns \texttt{OutputImage}.
  \item exception: Raises \texttt{InvalidInputException} if the input image is unsupported, unreadable, or corrupt.
\end{itemize}

\subsubsection{Local Functions}
None.

%----------------------------------------------------------
\section{MIS of WCAGCompliance Module} \label{wcagc}

\subsection{Module}
\texttt{WCAGComp}

\subsection{Uses}
Takes generated captions from the \texttt{CaptionGeneration} module and validates them against WCAG 2.1 AA criteria (\citet{WCAG}).

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{WCAG\_LEVEL}: String -- Target conformance level (e.g., \{"AA"\}); may be hardcoded.\\
\texttt{MIN\_CAPTION\_LEN}: $\mathbb{N}$ -- Minimum caption length (characters), may be hardcoded.\\
\texttt{MAX\_CAPTION\_LEN}: $\mathbb{N}$ -- Maximum caption length (characters), may be hardcoded.

\subsubsection{Exported Access Programs} 
\begin{center}
  \begin{tabular}{p{3cm} p{4cm} p{4cm} p{4cm}}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  initialize & - & - & - \\
  \hline
  checkCompliance & CaptionText:String & ComplianceReport:List & ValidationException \\
  \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\texttt{lastCheckedCaption}: String -- (Optional) caches the most recently validated caption for debugging/traceability.\\
\texttt{lastReport}: List -- (Optional) caches the most recently produced compliance report.

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
  \item \texttt{initialize} is called before \texttt{checkCompliance}.
  \item Constants may be hardcoded in the current implementation and moved to configuration later.
  \item State variables are optional; omitting them does not affect functional correctness.
  \item Assumes the input caption text is available and properly formatted for validation.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent \textbf{initialize():}
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item Initialize WCAG rule set and validation thresholds
  \end{itemize}
  \item output: None.
\end{itemize}

\noindent \textbf{checkCompliance(CaptionText)}:
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item (Optional) \texttt{lastCheckedCaption} := CaptionText
    \item Validate basic WCAG-aligned constraints (e.g. length bounds using \texttt{MIN\_CAPTION\_LEN} and \texttt{MAX\_CAPTION\_LEN})
    \item Construct a \texttt{ComplianceReport} summarizing pass/fail, warnings, and violations
    \item (Optional) \texttt{lastReport} := ComplianceReport
  \end{itemize}
  \item output: Returns a \texttt{ComplianceReport} summarizing accessibility validation results.
  \item exception: Raises \texttt{ValidationException} if validation cannot be completed or the input is invalid.
\end{itemize}

\subsubsection{Local Functions}
None.

%----------------------------------------------------------
\section{MIS of ModelOutput Module} \label{modout}

\subsection{Module}
\texttt{ModOut}

\subsection{Uses}
Called by the \texttt{WCAGCompliance} module after a caption has been validated,
or by the \texttt{CaptionGeneration} module when compliance checks are explicitly bypassed.
Sends the final caption output to the user-facing interface or backend display component.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}


\begin{center}
  \begin{tabular}{p{3cm} p{3.5cm} p{4cm} p{4cm}}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  initialize & - & - & OutputException \\
  \hline
  generateOutput & FinalCaption:String & DisplayConfirmation:\Bool & OutputException \\
  \hline
  \end{tabular}
  \end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.

\subsubsection{Environment Variables}
\texttt{DisplayChannel} -- User-facing interface or backend component responsible for presenting captions.

\subsubsection{Assumptions}
\begin{itemize}
  \item \texttt{initialize} is called before \texttt{generateOutput}.
  \item Assumes \texttt{FinalCaption} has already been designated as compliant or approved by the calling module.
  \item Assumes the display channel is active and able to receive caption text.
\end{itemize}
  
\subsubsection{Access Routine Semantics}
\noindent \textbf{initialize():}
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item Establish connection with display or backend output channel
  \end{itemize}
  \item output: None.
\end{itemize}

\noindent \textbf{generateOutput(FinalCaption):}
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item Receive \texttt{FinalCaption} from the calling module
    \item Transmit \texttt{FinalCaption} to \texttt{DisplayChannel} for presentation
  \end{itemize}
  \item output: Returns \texttt{DisplayConfirmation} indicating successful delivery.
  \item exception: Raises \texttt{OutputException} if transmission to the display channel fails.
\end{itemize}

\subsubsection{Local Functions}
None.

%----------------------------------------------------------
\section{MIS of AIModelTraining Module} \label{aitrain}

\subsection{Module}
\texttt{AITrain}

\subsection{Uses}
Takes preprocessed data from the \texttt{DataPreprocess} module and trains a model that will later be used by the \texttt{CaptionGeneration} module for alt-text generation.

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{DEFAULT\_MODEL\_ID}: String -- Default model identifier/architecture used for training (may be hardcoded).\\
\texttt{MAX\_EPOCHS}: $\mathbb{N}$ -- Maximum number of training epochs (may be hardcoded).\\
\texttt{BATCH\_SIZE}: $\mathbb{N}$ -- Training batch size (may be hardcoded).\\
\texttt{LEARNING\_RATE}: \Real -- Default learning rate (may be hardcoded).\\
\texttt{CHECKPOINT\_DIR}: String -- Directory where checkpoints are written (may be hardcoded).\\
\texttt{CHECKPOINT\_FREQ}: $\mathbb{N}$ -- Save checkpoint every k steps/epochs (may be hardcoded).\\
\texttt{RANDOM\_SEED}: $\mathbb{N}$ -- Seed for reproducibility (optional; may be omitted in early versions).

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{3.5cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
initializeModel & configPath: String & - & ConfigFileNotFoundException \\
\hline
trainModel & trainingData: Dataset & trainedModel: Model & TrainingException \\
\hline
saveCheckpoint & progress: Integer & - & WriteErrorException \\
\hline
\hline
saveTrainedModel & - & - & WriteErrorException \\

\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\texttt{trainedModel}: Stores the trained model instance.\\
\texttt{checkpointDir}: String. This stores the checkpoint directory path.\\
\texttt{modelSavePath}: String. This stores the file path used to save the final trained model.


\subsubsection{Environment Variables}
\texttt{cpu}: Device. This is the CPU execution device.\\
\texttt{gpu}: Device. This is the GPU execution device (it may be unavailable).\\
\texttt{checkpointDir}: String. This is the writable checkpoint directory path.\\
\texttt{modelSavePath}: String. This is the writable file path for the final trained model.

\subsubsection{Assumptions}
\begin{itemize}
  \item The input data is valid and preprocessed.
  \item The system has sufficient computational resources.
  \item The configuration file exists and can be accessed (may be a default/hardcoded configuration in early versions).
  \item Constants may be hardcoded in the current implementation and moved to configuration later.
  \item \texttt{initializeModel} is called before \texttt{trainModel} and \texttt{saveCheckpoint}.

\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{initializeModel(configPath):}
\begin{itemize}
  \item transition: Loads or initializes the model structure and related parameters based on \texttt{configPath} (or defaults).
  \item output: None.
  \item exception: Raises \texttt{ConfigFileNotFoundException} if the configuration is missing, unreadable, or invalid.
\end{itemize}

\noindent \textbf{trainModel(trainingData):}
\begin{itemize}
  \item transition: Trains the model on provided data and updates \texttt{trainedModel}.
  \item output: Returns the trained model.
  \item exception: Raises \texttt{TrainingException} if training fails due to invalid data, insufficient resources, or runtime errors.
\end{itemize}

\noindent \textbf{saveCheckpoint(progress):}
\begin{itemize}
  \item transition: Saves the model’s current state to \texttt{CHECKPOINT\_DIR} for recovery and future use.
  \item output: None.
  \item exception: Raises \texttt{WriteErrorException} if the checkpoint cannot be written (e.g., permission issues, missing directory, or I/O failure).
\end{itemize}

\noindent \textbf{saveTrainedModel():}
\begin{itemize}
  \item transition: Serializes \texttt{trainedModel} to \texttt{modelSavePath}.
  \item output: None.
  \item exception: Raises \texttt{WriteErrorException} if the model cannot be written to \texttt{modelSavePath}.
\end{itemize}


\subsubsection{Local Functions}
\begin{itemize}
  \item \textbf{splitData(NewFilePath:String) \texttt{->} TestPath:String, TrainPath:String, ValPath:String}: Divides input data into training, validation, and testing portions.
\end{itemize}


%----------------------------------------------------------
\section{MIS of CaptionGeneration Module} \label{capgen}

\subsection{Module}
\texttt{CapGen}

\subsection{Uses}
Uses the trained model from the \texttt{AIModelTraining} module to generate descriptive alt-text for input images.

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{MAX\_CAPTION\_LEN}: $\mathbb{N}$ -- Maximum generated caption length (tokens/words) (may be hardcoded).\\
\texttt{MIN\_CAPTION\_LEN}: $\mathbb{N}$ -- Minimum caption length to avoid under-description (optional).\\
\texttt{DECODE\_STRATEGY}: String -- Decoding strategy (e.g., \{"greedy","beam"\}) (may be hardcoded).\\

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{3cm} p{3.5cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
loadModel & modelPath: String & - & ModelLoadException \\
\hline
generateCaption & image: Image & caption: String & GenerationException \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\texttt{loadedModel}: Stores the active trained model used for caption generation.

\subsubsection{Environment Variables}
\texttt{cpu}: Device. This is the CPU execution device.\\
\texttt{gpu}: Device. This is the GPU execution device (it may be unavailable).\\
\texttt{device}: Device. This is the selected device used for inference.

\subsubsection{Assumptions}
\begin{itemize}
  \item A valid trained model is available and compatible with the input format.
  \item Input images are properly preprocessed.
  \item Constants may be hardcoded in the current implementation and moved to configuration later.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent \textbf{loadModel(modelPath)}:
\begin{itemize}
  \item transition: Loads the trained model from \texttt{modelPath} into memory as \texttt{loadedModel}.
  \item output: None.
  \item exception: Raises \texttt{ModelLoadException} if the model file is missing, unreadable, or incompatible.
\end{itemize}

\noindent \textbf{generateCaption(image)}:
\begin{itemize}
  \item transition: Uses \texttt{loadedModel} to generate a caption for \texttt{image} using \texttt{DECODE\_STRATEGY}.
\item output: \texttt{caption}.
  \item exception: Raises \texttt{GenerationException} if inference fails or a valid caption cannot be produced.
\end{itemize}

\subsubsection{Local Functions}
None.

%----------------------------------------------------------
\section{MIS of FeedbackMetrics Module} \label{modmetric}

\subsection{Module}
\texttt{ModMetric}

\subsection{Uses}
Receives generated captions from the \texttt{WCAGCompliance} module, evaluates their 
overall quality and accessibility, and sends the resulting performance scores to the 
\texttt{FeedbackIntegration} module for further model improvement.

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{SCORE\_RANGE}: Tuple -- Allowed score range (e.g. (0, 100)); may be hardcoded.\\
\texttt{PASS\_THRESHOLD}: $\mathbb{N}$ -- Minimum acceptable aggregate score; may be hardcoded.\\
\texttt{METRIC\_WEIGHTS}: Tuple -- (Optional) weighting factors for aggregate scoring; may be omitted in early versions.

\subsubsection{Exported Access Programs}
\begin{center}
  \begin{tabular}{p{3cm} p{3.5cm} p{4cm} p{4cm}}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    initialize & - & - & - \\
    \hline
    evaluateCaption & CaptionText:String & PerformanceScores: List[Tuple[String, Float]]
 & EvaluationException \\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\texttt{lastScores}: List -- (Optional) caches the most recently produced \texttt{PerformanceScores}.\\
\texttt{aggregateScore}: $\mathbb{Z}$ -- (Optional) most recent computed overall score.

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
  \item \texttt{initialize} is called before \texttt{evaluateCaption}.
  \item Constants may be hardcoded in the current implementation and moved to configuration later.
  \item State variables are optional; omitting them does not affect functional correctness.
  \item Assumes generated captions are available and that the chosen evaluation metrics are accessible.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent \textbf{initialize():}
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item Initialize evaluation metrics and scoring weights
  \end{itemize}
  \item output: None.
\end{itemize}

\noindent \textbf{evaluateCaption(CaptionText)}:
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item Compute performance indicators according to the selected metrics
    \item (Optional) compute \texttt{aggregateScore} and clamp to \texttt{SCORE\_RANGE}
    \item (Optional) \texttt{lastScores} := PerformanceScores(List[Tuple[String, Float]])
  \end{itemize}
  \item output: Returns \texttt{PerformanceScores}, a list of numerical scores summarizing caption quality and accessibility.
  \item exception: Raises \texttt{EvaluationException} if evaluation cannot be completed.
\end{itemize}

\subsubsection{Local Functions}
None.

%----------------------------------------------------------
\section{MIS of FeedbackIntegration Module} \label{modint}

\subsection{Module}
\texttt{ModInt}

\subsection{Uses}
Consumes performance scores from the \texttt{FeedbackMetrics} module and applies them to update model parameters 
in the \texttt{AIModelTraining} module, closing the feedback loop after inference.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{3cm} p{6cm} p{3cm} p{3cm}}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    initialize & - & - & - \\
    \hline
    updateModel & PerformanceScores: (List[Tuple[String, Float]]) & UpdateAck:\Bool & UpdateException \\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\texttt{modelState}: current model parameters selected for (re)training.

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
  \item \texttt{initialize} is called before \texttt{updateModel}.
  \item Assumes valid performance scores are provided by the \texttt{FeedbackMetrics} module and that retraining 
  can be invoked in \texttt{AIModelTraining}.

\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent \textbf{initialize():}
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item Initialize feedback integration state and model update hooks
  \end{itemize}
  \item output: None.
\end{itemize}

\noindent \textbf{updateModel(PerformanceScores):}
\begin{itemize}
  \item transition: updates \texttt{modelState} and signals \texttt{AIModelTraining} to (re)train with revised parameters.
  \item output: returns \texttt{UpdateAck} confirming that the update request was accepted.
  \item exception: raises \texttt{UpdateException} if parameter update or retraining trigger fails.
\end{itemize}

\subsubsection{Local Functions}
None.

%---------------------------------------------------------
\section{MIS of BackendController Module} \label{Module}

\subsection{Module}

\texttt{BackendController}

\subsection{Uses}
Serves as the coordinator between the frontend, backend and machine
learning modules.
\begin{itemize}
  \item Receives authentication and session status from the AuthenticationService Module (see Section~\ref{Module:AuthenticationService}) and SessionManagement module (see Section~\ref{Module:SessionManagement}), respectively.
  \item Sends uploaded images to the ImageValidation module (see Section~\ref{Module: ImageValid}) and receives validation results. 
  \item Sends validated inputs to the DataPreprocess module (see Section~\ref{datapp} )
  \item Sends errors and log events to the Logging module (see Section ~\ref{LogModule})
  \item Receives the generated alt text from the ModelOutput module (see Section \ref{modout}) to be presented to the user.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{SESSION\_TIMEOUT}: $\mathbb{N}$ - Specifies the amount of
time in minutes a users logged-in session can remain active for
before requiring reauthentication.\\ \\
\texttt{API\_RESPONSE\_TIMEOUT}: $\mathbb{N}$ - Specifies the amount
of time in seconds that the controller waits for a response from
other modules before timing out.\\

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{6cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
validateUser & userToken:String & userStatus:\Bool & InvalidTokenException \\
\hline
validateImage & imagePath:String, userToken: UUID & imagePath:\Bool & InvalidImageException\\
\hline
sendToModel & imagePath:String, userToken: UUID & - & AltTextGenerationError\\
\hline 
getAltText & imagePath:String, userToken: UUID & altText:String & AltTextNotFoundException\\
\hline 
returnToFrontend & altText or errorMsg: String, userID: UUID & - & UIUnreachableException \\
\hline
updateAltText & altText:String, userID:UUID & - & SessionStateSaveException\\
\hline 
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.

\subsubsection{Environment Variables}
\texttt{Filesystem} - Used to retrieve images using the file path provided by users. 

\subsubsection{Assumptions}

\begin{itemize}
  \item MainScreen, AuthenticationService, ImageValidation and DataPreprocess modules are correctly operating and reachable. 
  \item Network connection is available for API communication. 
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{validateUser(userToken)}:
\begin{itemize}
  \item transition: Sends the \texttt{userToken} to the User
    Authentication Module for Verification.
  \item output: Returns \texttt{True} if the user is valid, otherwise
    \texttt{False} is returned.
  \item exception: \texttt{InvalidTokenException} is raised if token
    is expired or cannot be validated.
\end{itemize}

\noindent \textbf{validateImage(image,userToken)}:
\begin{itemize}
  \item transition: Sends the uploaded image and associated user
    token to the Image Validation Module for verification of file type and size.
  \item output:  Returns \texttt{True} if the image was successfully
    validated, otherwise \texttt{False} is returned.
  \item exception:  \texttt{InvalidImageException} is raised if the
    image fails the validation process and does not meet system requirements.
\end{itemize}

\noindent \textbf{sendToModel(image,userToken)}:
\begin{itemize}
  \item transition: Sends the validated image and associated user
    token to the Machine Learning Module to initiate alt-text generation.
  \item output:  None.
  \item exception: \texttt{AltTextGenerationError} is raised if the
    Machine Learning Module fails to process image or generate alt text.
\end{itemize}

\noindent \textbf{returnToFrontend(alt Text or errorMsg, userToken)}:
\begin{itemize}
  \item transition: Sends the generated alt text or corresponding
    error message to the Frontend Module.
  \item output:  None.
  \item exception: \texttt{FrontendUnreachableException} is raised if
    the Frontend Module cannot be reached.
\end{itemize}

\noindent \textbf{updateAltText(altText, userID)}:
\begin{itemize}
  \item transition: Updates the user's existing alt-text generation
    to include their changes.
  \item output:  None
  \item exception: \texttt{SessionStorageException} is raised if the
    system is unable to save the modified alt text to the users session history.
\end{itemize}

%---------------------------------------------------------
\section{MIS of AuthenticationService Module}
\label{Module:AuthenticationService}

\subsection{Module}

\texttt{AuthenticationService}

\subsection{Uses}
This module is responsible for managing and validating user
authentication across the Reading4All system. It ensures that only
verified users can upload, edit, or retrieve images and generated alt text.
\begin{itemize}
  \item LoginScreen Module: Receives user login and logout requests,
    sends authentication tokens.
  \item Session Management Module: Manages active sessions and stores
    validated tokens.
  \item Backend Controller Module: Requests user validation before
    allowing access to backend operations.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{TOKEN\_EXPIRY\_TIME}: $\mathbb{N}$ - Duration in minutes
after which an authentication token expires. \\ \\
\texttt{MAX\_LOGIN\_ATTEMPTS}: $\mathbb{N}$ - Maximum number of
failed login attempts allowed before temporary account lockout. \\

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{3cm} p{4cm} p{3cm} p{4cm}}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    validateToken & userToken:String & Success:\Bool & InvalidTokenException \\
    \hline
    signInUser & credentials:String  & userToken:String &
    AuthenticationFailed-Exception \\
    \hline
    signOutUser & userToken:String & Success:\Bool & SessionNotFoundException \\
    \hline
    getCurrentUser & userToken:String & userID: String &
    UserNotAuthenticated-Exception \\
    \hline
    refreshToken & userToken:String & newToken:String & TokenRefreshException \\
    \hline
  \end{tabular}
\end{center}
\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{currentUser}: Stores information of the currently
    authenticated user (userID, role, status).
  \item \texttt{activeTokens}: List of active tokens issued during
    authenticated sessions.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item  LoginAPI to authentication the information of users
    attempting to sign in.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item The database or session store used for token verification is
    operational.
  \item Network connection to backend and session services is stable.
  \item All tokens follow the system-defined structure and encryption standard.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{validateToken(userToken)}:
\begin{itemize}
  \item transition: Compares provided token against valid session
    records in \texttt{SessionManagement}.
  \item output: Returns \texttt{True} if token is valid and active,
    otherwise \texttt{False}.
  \item exception: \texttt{InvalidTokenException} is raised if the
    token has expired or does not exist.
\end{itemize}

\noindent \textbf{signInUser(credentials)}:
\begin{itemize}
  \item transition: Verifies credentials (e.g., username and
    password) and issues a unique token for session creation.
  \item output: Returns a valid \texttt{userToken} on successful authentication.
  \item exception: \texttt{AuthenticationFailedException} is raised
    if credentials are invalid or user does not exist.
\end{itemize}

\noindent \textbf{signOutUser(userToken)}:
\begin{itemize}
  \item transition: Removes the associated token from the active
    token list and ends the user’s session.
  \item output: Returns \texttt{True} on successful logout.
  \item exception: \texttt{SessionNotFoundException} is raised if the
    token is invalid or session not found.
\end{itemize}

\noindent \textbf{getCurrentUser(userToken)}:
\begin{itemize}
  \item transition: Queries active sessions to identify the user
    associated with the token.
  \item output: Returns \texttt{userID} if token corresponds to an
    active session.
  \item exception: \texttt{UserNotAuthenticatedException} is raised
    if no active session exists for the token.
\end{itemize}

\noindent \textbf{refreshToken(userToken)}:
\begin{itemize}
  \item transition: Reissues a new token with an updated expiry time
    after verifying the old token’s validity.
  \item output: Returns \texttt{newToken}.
  \item exception: \texttt{TokenRefreshException} is raised if old
    token is expired or tampered.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
  \item \texttt{generateToken(userID)} — Creates a secure, encrypted
    token for the authenticated user.
  \item \texttt{encryptData(data)} — Encrypts sensitive
    authentication information before storage.
  \item \texttt{validateCredentials(credentials)} — Confirms user
    credentials against secure storage.
\end{itemize}

%---------------------------------------------------------
\section{MIS of SessionManagement Module} \label{Module:SessionManagement}

\subsection{Module}
\texttt{SessionManagement}

\subsection{Uses}
The Session Management module is responsible for creating, storing,
and maintaining active user sessions within the Reading4All system.
It also tracks the session-specific history of user interactions,
referencing corresponding entries in the Reading4All data. Other
modules, such as the Authentication Service and Backend Controller,
rely on it for validating active tokens and retrieving user activity
logs within the current session.
\begin{itemize}
  \item \textbf{Authentication Service:} Initiates creation,
    validation, and deletion of sessions.
  \item \textbf{Backend Controller:} Updates session history after
    each major user action (e.g., validateImage, sendToModel, getAltText).
  \item \textbf{Reading4All Data:} Serves as the persistent storage
    layer for user images and generated alt-text records, referenced
    by session data IDs.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{MAX\_SESSION\_DURATION}: $\mathbb{N}$ - Specifies the maximum
duration, in minutes, that a session remains active before expiration. \\ \\
\texttt{SESSION\_REFRESH\_INTERVAL}: $\mathbb{N}$ - The interval, in
minutes, at which session validity is checked or refreshed. \\ \\
\texttt{MAX\_SESSION\_HISTORY}: $\mathbb{N}$ - Maximum number of
interaction entries stored per session to prevent unbounded growth. \\

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{3.3cm} p{4.5cm} p{3.2cm} p{4cm}}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    createSession & userID:String & sessionToken:String &
    SessionCreation-Exception \\
    \hline
    storeSession & userID:String, sessionToken:String & success:\Bool
    & SessionStorageException \\
    \hline
    validateSession & userToken:String & success:\Bool &
    InvalidSessionException \\
    \hline
    deleteSession & userToken:String & success:\Bool &
    SessionNotFound-Exception \\
    \hline
    getSession & userToken:String & sessionData:String&
    SessionNotFound-Exception \\
    \hline
    appendInteraction & userToken:String, interactionEntry:String &
    success:\Bool & SessionNotFound-Exception \\
    \hline
    getSessionHistory & userToken:String, filter:String &
    interactionList:List & SessionNotFound-Exception \\
    \hline
    linkDataRecord & userToken:String, dataRecordID:String &
    success:\Bool & SessionNotFound-Exception \\
    \hline
    getRecentRecords & userToken:String, limit: $\mathbb{N}$ &
    dataRecordRefs:List & SessionNotFound-Exception \\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
  \item \texttt{activeSessions}: Mapping of \texttt{userID}
    $\rightarrow$ \texttt{sessionToken} representing currently active sessions.
  \item \texttt{sessionExpiry}: Mapping of \texttt{sessionToken}
    $\rightarrow$ expiry time.
  \item \texttt{sessionHistory}: Mapping of \texttt{sessionToken}
    $\rightarrow$ ordered list of interaction entries for that session.
  \item \texttt{sessionDataRefs}: Mapping of \texttt{sessionToken}
    $\rightarrow$ set of dataRecordIDs referencing Reading4All data entries.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
  \item \texttt{SystemClock}: Provides current time for session
    expiry calculations.
  \item \texttt{StorageService}: Fast-access storage for session and
    interaction data.
  \item \texttt{Browser}: Storing session tokens for the valid
    duration of user activity.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
  \item The system clock is synchronized to ensure accurate session
    expiry times.
  \item Tokens and user IDs are unique and securely generated.
  \item A fast-access storage service (e.g., in-memory cache or
    Redis) is available for storing session and interaction data.
  \item Reading4All data provides stable and retrievable
    \texttt{dataRecordID}s for cross-module referencing.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{createSession(userID)}:
\begin{itemize}
  \item transition: Generates a new session token, initializes empty
    history and data references, and sets the expiry time.
  \item output: Returns the created \texttt{sessionToken}.
  \item exception: Raises \texttt{SessionCreationException} if
    session creation fails.
\end{itemize}

\noindent \textbf{validateSession(userToken)}:
\begin{itemize}
  \item transition: None.
  \item output: Returns \texttt{True} if the session exists and is
    active, otherwise \texttt{False}.
  \item exception: Raises \texttt{InvalidSessionException} if the
    token is expired or invalid.
\end{itemize}

\noindent \textbf{appendInteraction(userToken, interactionEntry)}:
\begin{itemize}
  \item transition: Appends the provided \texttt{interactionEntry}
    (with timestamp and type) to \texttt{sessionHistory[userToken]}.
    If the maximum history size is exceeded, the oldest entry is removed.
  \item output: Returns \texttt{True} upon success.
  \item exception: Raises \texttt{SessionNotFoundException} if the
    token is not associated with an active session.
\end{itemize}

\noindent \textbf{linkDataRecord(userToken, dataRecordID)}:
\begin{itemize}
  \item transition: Associates the provided \texttt{dataRecordID}
    (from Reading4All data) with the user’s current session for
    future retrieval.
  \item output: Returns \texttt{True} upon success.
  \item exception: Raises \texttt{SessionNotFoundException} if no
    active session exists.
\end{itemize}

\noindent \textbf{getSessionHistory(userToken, filter)}:
\begin{itemize}
  \item transition: None.
  \item output: Returns a filtered list of interaction entries (e.g.,
    uploads, alt-text retrieval) for the specified session.
  \item exception: Raises \texttt{SessionNotFoundException} if the
    token is invalid or no session history exists.
\end{itemize}

\noindent \textbf{getRecentRecords(userToken, limit)}:
\begin{itemize}
  \item transition: None.
  \item output: Returns up to the specified number of recent
    \texttt{dataRecordID} references associated with the current session.
  \item exception: Raises \texttt{SessionNotFoundException} if no
    active session exists.
\end{itemize}

\noindent \textbf{deleteSession(userToken)}:
\begin{itemize}
  \item transition: Removes the token from active sessions and clears
    its associated history and data references.
  \item output: Returns \texttt{True} if deletion is successful.
  \item exception: Raises \texttt{SessionNotFoundException} if the
    token is invalid or not found.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
  \item \textbf{generateSessionToken(userID)}: Creates a secure,
    unique token for the given user.
  \item \textbf{updateExpiry(sessionToken)}: Extends the expiry time
    of a session on continued activity.
  \item \textbf{cleanExpiredSessions()}: Removes all expired sessions
    and their histories from storage.
  \item \textbf{applyHistoryFilter(history, filter)}: Applies
    filtering parameters (e.g., type, time range, status) to session
    history queries.
\end{itemize}

%---------------------------------------------------------
\section{MIS of ImageValidation Module} \label{Module: ImageValid}

\subsection{Module}
\texttt{ImageValidation}

\subsection{Uses}
None.
\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{MAX\_IMAGE\_SIZE}: $\mathbb{N}$ - Specifies the maximum file
size in (MB) allowed for uploaded images.\\
\texttt{MIN\_IMAGE\_SIZE}: $\mathbb{N}$ - Specifies the minimum file
size in (MB) allowed for uploaded images.\\
\texttt{ACCEPTED\_IMAGE\_TYPES}: \texttt{List of Strings}- Specifies
the accepted image file types.
\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{4 cm} p{5cm} p{3 cm} p{4cm}}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    validateImageFile & imagePath:String, userToken:UUID &
    imageStatus: \(\mathbb{B}\)& InvalidImageType-Exception \\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.

\subsubsection{Environment Variables}
\texttt{Filesystem} - Used to retrieve images using the file path
provided by users.

\subsubsection{Assumptions}

\begin{itemize}
  \item The \texttt{BackendController} module provides the
    ImageValidation module with an image file that is reachable for validation.
  \item The user has successfully been validated through the user
    authentication process.
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent \textbf{validateImageFile(imagePath, userToken)}
\begin{itemize}
  \item transition: Verifies that the inputted image meets size and
    format requirements.
  \item output: Returns \texttt{True} if the image meets size and
    format requirements, otherwise \texttt{False} is returned.
  \item exception: \texttt{InvalidImageException} is raised if the
    image cannot be reached and therefore cannot be validated.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
  \item \textbf{verifyFileType(imagePath)}: Checks that the images
    file type matches a type found in \texttt{ACCEPTED\_IMAGE\_TYPES}.
  \item \textbf{verifyFileSize(imagePath)}: Checks that the images
    size falls between \texttt{MIN\_IMAGE\_SIZE} and \texttt{MAX\_IMAGE\_SIZE}.
  \item \textbf{verifyFileReachable(imagePath)}: Checks that the
    image can be accessed and opened successfully.
\end{itemize}

%---------------------------------------------------------
\section{MIS of Logger Module} \label{LogModule}

\subsection{Module}
\texttt{Logger}

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{LOG\_FILE\_PATH}: String - Specifies the location of where
the logs should be stored.\\
\texttt{LOG\_TYPE}: List of Strings - Specifies the possible log
types such as an \texttt{Event} and \texttt{Error}.\\

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{2cm} p{7cm} p{3cm} p{3cm}}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    logEvent & eventMssg:String, logType:String & - & LogWriteException\\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}
\texttt{Filesystem} - Used to save the log files to the specified path.

\subsubsection{Assumptions}
\begin{itemize}
  \item The file system is available and logs can be saved to it.
  \item The LOG\_FILE\_PATH location can be accessed.
  \item Log messages are provided in string format by the Backend
    Controller Module.
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent \textbf{logEvent(eventMssg, logType)}:
\begin{itemize}
  \item transition: Creates an log entry containing the time of event
    occur, type and message.
  \item output: An updated log file with new event or error entry added.
  \item exception: \texttt{LogWriteException} is raised if the log
    file cannot be accessed or written to.
\end{itemize}

\subsubsection{Local Functions}

None.

%---------------------------------------------------------
\section{MIS of UserInterfaceInteractions Module}\label{UI_Interactions}

\subsection{Module}

\texttt{InteractionsUI}

\subsection{Uses}
This module uses \texttt{BackendController} to authenticate the users
that are signing in, and to obtain the
generated alternative text. It also uses the display modules
(\texttt{MainScreen}, \texttt{LogInScreen},
\texttt{ShowHistoryScreen}) to render the different screens and
interfaces to the users.

\subsection{Syntax}

\subsubsection{Exported Constants}

\texttt{SUPPORTED\_IMG\_TYPES = \{"PNG", "JPEG"\}}\\
\texttt{OUTPUT\_FILE\_TYPE = \{".txt"\}}\\
\texttt{MAX\_IMG\_SIZE = 10MB}

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{2.5cm} p{4cm} p{4cm} p{3cm}}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    uploadImage & imageFilePath:String & Success:\Bool &
    FileNotFound, FileTypeNotSupported, FileTooLarge\\
    \hline
    downloadText & altText:String & altTextFile:String & NetworkError \\
    \hline
    copyText & altText:String & Success:\Bool & ClipboardError \\
    \hline
    editText & altText:String, editedText:String & Success:\Bool &
    NetworkError \\
    \hline
    signIn & token:String & Success:\(\mathbb{B}\) & AuthError \\
    \hline
    signOut & - & Success:\(\mathbb{B}\) & AuthError \\
    \hline
    showHistory & - & Success:\(\mathbb{B}\) & NetworkError \\

    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{Clipboard} - system's clipboard interface for copy function.
  \item \texttt{HTTPClient} - used to call backend services.
  \item \texttt{Keyboard} - provides key press events that trigger
    corresponding UI action handlers such as sign in and upload image.
  \item \texttt{FileSystem} - used to access file paths.
\end{itemize}

\subsubsection{Assumptions}

\begin{itemize}
  \item \texttt{Clipboard} access is enabled by the user for \texttt{copyText}.
  \item User allows system to access files for uploading images and
    downloading alt text.
  \item \texttt{uploadImage} is called before any other access program.
  \item Each exported access program represents an event handler that
    is invoked in response to user-triggered actions such as mouse
    clicks and keyboard presses on the user interface.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{uploadImage(imageFilePath)}:
\begin{itemize}
  \item transition: \texttt{HTTPClient} sends the image bytes into
    the backend service which stores the image for that session, and
    communicates
    with the AI model for alt text generation.
  \item output: returns \texttt{true} iff the backend server
    acknowledges and is able to process the image, returns
    \texttt{false} otherwise.
  \item exception: \texttt{FileNotFound},
    \texttt{FileTypeNotSupported} (not in \texttt{SUPPORT\_IMG\_TYPES}),
    and \texttt{FileTooLarge} (not within \texttt{MAX\_IMG\_SIZE})
\end{itemize}

\noindent \textbf{downloadText(altText)}:
\begin{itemize}
  \item transition: None.
  \item output: a \texttt{.txt} payload that contains the generated alt text.
  \item exception: \texttt{NetworkError}.
\end{itemize}

\noindent \textbf{copyText(altText)}:
\begin{itemize}
  \item transition: \texttt{Clipboard} := altText
  \item output: returns \texttt{true} iff clipboard write succeeds,
    returns \texttt{false} otherwise.
  \item exception: \texttt{ClipboardError}.
\end{itemize}

\noindent \textbf{editText(altText,editedText)}:
\begin{itemize}
  \item transition: \texttt{HTTPClient} sends update to backend and
    stored altText for uploaded image is replaced with editedText.
  \item output: return \texttt{true} iff server acknowledges the
    update, returns \texttt{false} otherwise.
  \item exception: \texttt{NetworkError}.
\end{itemize}

\noindent \textbf{signIn(token)}:
\begin{itemize}
  \item transition: if \texttt{token} is valid according to
    BackendController then user session becomes active.
    Otherwise no state change.
  \item output: return \texttt{true} iff user session is active,
    returns \texttt{false} otherwise.
  \item exception: \texttt{AuthenticationError}.
\end{itemize}

\noindent \textbf{signOut()}:
\begin{itemize}
  \item transition: terminates current active user session if any exists.
    Otherwise no state change.
  \item output: return \texttt{true} iff user session is was
    terminated, returns \texttt{false} otherwise.
  \item exception: \texttt{AuthenticationError}.
\end{itemize}

\noindent \textbf{showHistory()}:
\begin{itemize}
  \item transition: requests the ShowHistoryScreen module to render
    the History Screen using the current stored alt text session history.
  \item output: return \texttt{true} iff history was successfully
    shown, returns \texttt{false} otherwise.
  \item exception: \texttt{AuthenticationError}.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \textbf{isSupportedImage(filePath:String) \texttt{->} \Bool}:
    returns \texttt{true} if
    the file type $\in$ \texttt{SUPPORTED\_IMG\_TYPES}.
  \item \textbf{checkImgSize(filePath:String) \texttt{->} \Bool}:
    returns \texttt{true} if
    the size of the image $\le$ \texttt{MAX\_IMG\_SIZE}.
  \item \textbf{saveAsTxt(altText: String) \texttt{->}
    filePath:String}: wraps generated alt text
    into a \texttt{.txt} file for \texttt{downloadText()}.
  \item \textbf{buildUploadPayload(filePath: String) \texttt{->}
    Binary}: reads the file and constructs the binary payload for the
    \texttt{uploadImage} function to send to the BackendController module.
\end{itemize}

%---------------------------------------------------------
\section{MIS of MainScreen Module}\label{MainScreen}

\subsection{Module}

\texttt{MainScreen}

\subsection{Uses}
This module uses \texttt{AccessibilityUI} to ensure that the content
within the interface is
compatible with screen readers and tabbable by a keyboard.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{2.5cm} p{4cm} p{4cm} p{3cm}}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    renderMain & - & - & RenderError, AccessibilityError \\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

\texttt{DOM} - active document element into which UI is rendered.

\subsubsection{Assumptions}

\begin{itemize}
  \item Accessibility services are provided by the
    \texttt{AccessibilityUI} module for screen reader announcements,
    landmark management, initial focus, and keyboard navigation
    helpers. This module will provide notifications to
    the \texttt{AccessibilityUI} module.
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent \textbf{renderMain()}:
\begin{itemize}
  \item transition: update DOM to reflect main screen containing the
    upload page, then call on \texttt{AccessibilityUI} to
    handle compatibility with screen readers and keyboard navigation.
  \item output: None.
  \item exception: \texttt{RenderError}, \texttt{AccessibilityError}.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \textbf{ensureMainLandmark()  \texttt{->} \Bool}: calls
    \texttt{AccessibilityUI}
    to mark/set the main landmark.
  \item \textbf{setInitialFocus()\texttt{->} \Bool}: calls
    \texttt{AccessibilityUI}
    to move focus to the main region.
  \item \textbf{announceMainLoaded() \texttt{->} \Bool}: calls
    \texttt{AccessibilityUI}
    to announce screen load.

\end{itemize}

%---------------------------------------------------------
\section{MIS of ShowHistoryScreen Module}\label{showHistory}

\subsection{Module}

\texttt{ShowHistoryScreen}

\subsection{Uses}

This module uses \texttt{AccessibilityUI} to ensure that the content
within the interface is
compatible with screen readers and tabbable by a keyboard.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{2.5cm} p{4cm} p{4cm} p{3cm}}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    showHistory & - & - & RenderError, AccessibilityError\\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

\texttt{DOM} - active document element into which UI is rendered.

\subsubsection{Assumptions}

\begin{itemize}
  \item If history is shown, a valid and authenticated session already exists.
  \item \texttt{AccessibilityUI} is used for announcements and focus.
  \item History content to display is already prepared by the
    \texttt{InteractionsUI} module through
    the \texttt{BackendController} module.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{showHistory()}:
\begin{itemize}
  \item transition: update DOM to reflect user's current session
    history, then call on \texttt{AccessibilityUI} to
    handle compatibility with screen readers and keyboard navigation.
  \item output: None.
  \item exception: \texttt{RenderError}, \texttt{AccessibilityError}.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \textbf{ensureMainLandmark()  \texttt{->} \Bool}: calls
    \texttt{AccessibilityUI}
    to mark/set the main landmark.
  \item \textbf{setInitialFocus()\texttt{->} \Bool}: calls
    \texttt{AccessibilityUI}
    to move focus to the main region.
  \item \textbf{announceHistoryLoaded() \texttt{->} \Bool}: calls
    \texttt{AccessibilityUI}
    to announce history screen load.
\end{itemize}

%---------------------------------------------------------
\section{MIS of LogInScreen Module}\label{LogInScreen}

\subsection{Module}

\texttt{LogInScreen}

\subsection{Uses}

This module uses \texttt{AccessibilityUI} to ensure that the content
within the interface is
compatible with screen readers and tabbable by a keyboard.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{2.5cm} p{3cm} p{3cm} p{4cm}}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    renderLogIn & - & - & RenderError, AccessibilityError \\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

\texttt{DOM} - active document element into which UI is rendered.

\subsubsection{Assumptions}

\begin{itemize}
  \item \texttt{AccessibilityUI} is used for announcements and focus.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{renderLogIn()}:
\begin{itemize}
  \item transition: update \texttt{DOM} to reflect log in screen with
    username and password fields,
    then call on \texttt{AccessibilityUI} to
    handle compatibility with screen readers and keyboard navigation.
  \item output: None.
  \item exception: \texttt{RenderError}, \texttt{AuthenticationError}.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
  \item \textbf{ensureMainLandmark()  \texttt{->} \Bool}: calls
    \texttt{AccessibilityUI}
    to mark/set the main landmark.
  \item \textbf{setInitialFocus(username:String)\texttt{ -> }\Bool}:
    calls \texttt{accessibilityUI} to move keyboard focus to the username
    input field after the log in screen is rendered.
  \item \textbf{announceLogInLoaded() \texttt{->} \Bool}: calls
    \texttt{AccessibilityUI}
    to announce log in screen load.
\end{itemize}

%---------------------------------------------------------
\section{MIS of UserInterfaceAccessibility Module}\label{UI_accessibility}

\subsection{Module}

\texttt{AccessibilityUI}

\subsection{Uses}

This module uses the display modules (\texttt{MainScreen}, \texttt{LogInScreen},
\texttt{showHistorScreeny}) to receive notifications of user activity
to announce changes
through a screen reader and apply keyboard navigation to the content
in those screens.
\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{4cm} p{4cm} p{3cm} p{3cm}}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    ensureMainLandmark & rootSel:String & Success:\(\mathbb{B}\) &
    AccessibilityError\\
    setInitialFocus & targetSel:String & Success:\(\mathbb{B}\) &
    AccessibilityError\\
    announce & msg:String & Success:\(\mathbb{B}\) & AccessibilityError\\
    applyKeyboardNav & scopeSel:String & Success:\(\mathbb{B}\) &
    AccessibilityError\\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}
\texttt{DOM} - the active HTML document containing interactive elements \\
\texttt{ScreenReaderAPI} - hidden live region nodes used to deliver
announcements to screen readers
for compatibility\\
\texttt{Keyboard} - delivers keypress events to use for keyboard navigation\\

\subsubsection{Assumptions}

\begin{itemize}
  \item The page allows insertion of valid ARIA (\citet{ARIA}) live region nodes
  \item \texttt{MainScreen}, \texttt{LogInScreen},
    \texttt{ShowHistoryScreen} modules calls \texttt{AccessibilityUI}
    to announce changes on the user interface.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{ensureMainLandmark(rootSel:String)}:
\begin{itemize}
  \item transition: ensure that the element selected by
    \texttt{rootSel} is the page’s
    main landmark (i.e. \texttt{<main>}).
  \item output: returns \texttt{true} if main landmark was present
    after the call, returns \texttt{false}
    otherwise.
  \item exception: \texttt{AccessibilityError}.
\end{itemize}

\noindent \textbf{setInitialFocus(targetSel:String)}:
\begin{itemize}
  \item transition: move keyboard focus to the element matching
    \texttt{targetSel} for keyboard navigation;
    if not focusable, make it focusable for the interaction.
  \item output: returns \texttt{true} if focus was moved, returns \texttt{false}
    otherwise.
  \item exception: \texttt{AccessibilityError}.
\end{itemize}

\noindent \textbf{announce(msg:String)}:
\begin{itemize}
  \item transition: update the ARIA (\citet{ARIA}) live region with \texttt{msg}
    so screen readers can announce the change.
  \item output: returns \texttt{true} if live region was updated,
    returns \texttt{false}
    otherwise.
  \item exception: \texttt{AccessibilityError}.
\end{itemize}

\noindent \textbf{applyKeyboardNav(scopeSel:String)}:
\begin{itemize}
  \item transition: attach handlers within \texttt{scopeSel}
    (container that gets arrow-key navigation behaviour)
    to enable roving-tabindex and arrow-key navigation (i.e.,
    ArrowLeft/Right/Up/Down, Home/End, Enter/Space activation)
    without changing application state.
  \item output: returns \texttt{true} if handlers are attached
    successfully, returns \texttt{false}
    otherwise.
  \item exception: \texttt{AccessibilityError}.
\end{itemize}


\subsubsection{Local Functions}
\begin{itemize}
  \item \textbf{getLiveRegion(type:String)  \texttt{->} Node}:
    returns the hidden live region for announcements;
    calls on \texttt{createLiveRegion(type: String)} if no live
    region to create one.
  \item \textbf{createLiveRegion(type:String) \texttt{->} Node}:
    creates and returns the hidden live region for announcements.
  \item \textbf{isFocusable(node:Node) \texttt{ -> }\Bool}: returns
    \texttt{true} if \texttt{node} is focusable.
  \item \textbf{applyRovingTabindex(container:Node) \texttt{->}
    \Bool}: ensures exactly one child is tabbable
    and others are reachable via arrow keys.
  \item \textbf{moveFocus(container:Node, dir:String) \texttt{->}
    \Bool}: shifts focus to the next or previous roving
    item given \texttt{dir} $\in$ \texttt{{ "next","prev","home","end" }}.
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex} \\

\textbf{Dhruv Sardana - Reflection}
\begin{enumerate}
  \item \textbf{What went well while writing this deliverable?} \\
  During the writing of this deliverable, it helped me understand our system design 
  and coding to a much better extent where I was able to identify the modules and 
  their types more clearly. The low level design became more apparent and it helped us 
  understand the flow of data between the modules. It gave me clarification on what kind 
  of data tables we needed to create for each module.
  

  \item \textbf{What pain points did you experience during this deliverable, and how
    did you resolve them?} \\
    During the writing of this deliverable, one of the pain points I experienced was understanding how to 
    deploy the CI.CD pipeline for our project. I was not very familiar with GitHub actions and how to implement it.
    I researched about it and found some tutorials online that helped me understand how to set it up. 
    I also discussed with my team members. Another thing that I researched was what kind of databases we would
    be needing and how it would affect our modules. Such having a signup verification module or just keeping
    it under authentication module. I discussed with backend subteam and we came to a conclusion to keep it under 
    authentication module 
  
\end{enumerate}

\textbf{Casey Francine Bulaclac - Reflection}
\begin{enumerate}
  \item \textbf{What went well while writing this deliverable?} \\
    When writing the Rev 0 design document deliverable, what went
    well was applying
    the TA and our peer review group's feedback. The feedback we were
    given from Rev -1
    was very helpful in learning what was missing and/or what may
    have been confusing
    with this deliverable. This allowed our group to think more thorougly about
    our modules and how each one connects to each other.

  \item \textbf{What pain points did you experience during this
      deliverable, and how
    did you resolve them?} \\
    When writing the Rev 0 design document deliverable, a pain point
    was trying to
    correctly identify the type of each module. This was quite
    difficult at the beginning,
    for example, trying to understand what an abstract object is took
    our group a long
    time. To resolve this, we went over our types with our TA to
    ensure we understood it
    correctly, and asked for extra clarification regarding the module types.
\end{enumerate}

\textbf{Nawaal Fatima - Reflection}
\begin{enumerate}
  \item \textbf{What went well while writing this deliverable?} \\
  During this deliverable, knowing precisely what had to be changed was good. It provided me with direction and structure. 
  I wasn't left feeling frustrated on why we had lost marks on certain sections due to the very detailed feedback. Also, 
  communication among the team vastly improved and expectations were properly met. We had more consistent updates between meetings in 
  our team, and toour supervisor.

  \item \textbf{What pain points did you experience during this deliverable, and how
    did you resolve them?} \\
  Juggling between coding and fixing past mistakes, then inplementing into the code any changes in an agile way was a bit hectic for me. 
  I had to think ahead and 2 steps behind at the same time which is still hard for me to do but Im learning! To resolve these issues, 
  I first revisited all that had to be done and then made a sequential plan to iterate through changes, discussing with the team/subteam 
  when required. It taught me to be agile. I'm also slowly learning to not be a perfect coder - I have to make it exist first before it can 
  be "good" and even then there's a ton of trade offs! 
  
\end{enumerate}

\textbf{Fiza Sehar Individual - Reflection}

\begin{enumerate}
  \item \textbf{What went well while writing this deliverable?}\\
  Since we had already discussed many implementation details while building, the TA feedback was clear and actionable. I refined the environment variables to be more specific and consistent across modules by separating \texttt{cpu} and \texttt{gpu}, and replacing vague terms like ``Filesystem'' with explicit paths such as \texttt{checkpointDir} and \texttt{modelSavePath}. I also tightened the access routine semantics so the outputs match what is declared in the access program tables.

  \item \textbf{What pain points did you experience during this deliverable, and how did you resolve them?}\\
  The main pain point was deciding how detailed the MIS should be without adding unnecessary complexity. In particular, it was unclear whether model save locations should be treated as parameters or environment variables, and how to describe CPU/GPU usage consistently. I resolved this by aligning directly with the TA comments, making dependencies explicit by naming the file paths, standardizing device naming (\texttt{cpu}, \texttt{gpu}, \texttt{device}), and adding a simple precondition assumption (model initialized or loaded before use) to remove ambiguity.
\end{enumerate}


\textbf{Moly Mikhail Individual - Reflection}

\begin{enumerate}
  \item \textbf{What went well while writing this deliverable?}\\
  I believe many things went well while writing this deliverable. Firstly having to iterations was greatly beneficial. 
  This allowed us to iterate on our design and make improvements based on numerous things. 
  We made changes based on our TA feedback from the Rev0 Design Document deliverable, as well as peer feedback. 
  This was really helpful as a lot of the feedback pointed out inconsistences and gaps within our design.
  I also found it helpful to reflect on our design after beginning the implementation process. Often when beginning to code 
  and implement our design, small differences were revealed. It was helpful to compare our initial design to how we were implementing and make decisions on how on the best way to proceed. 
  \item \textbf{What pain points did you experience during this deliverable, and how did you resolve them?}\\
  The first pain point I experienced during this deliverable was reviewing the module types we had initially chosen
  and ensuring they made sense and aligned with the definition of the types. 
  Looking specifically, at abstract objects it was initially confusing what an initializer method was and the difference between a constrcutor. However, 
  after meeting with our TA, I was able to ask about this and get clarification, which was really helpful.

\end{enumerate}



\textbf{Team Reflection}
\begin{enumerate}
  \item What went well while writing this deliverable?
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?

  \item \textbf{Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?} \\
  When designing the frontend modules, including MainScreen, ShowHistoryScreen, and 
  LogInScreen, our supervisor, Jing, provided very useful guidance on the layout, logic and 
  style of these interfaces. Jing had experience in working with our potential users so 
  she was able to give us advice on how to design our frontend modules. These suggestions 
  helped ensure the design was optimized for accessibility.

  \item \textbf{While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?}
  When creating the Module Guide and Module Interface Specification documents, we had 
  to make modifications to our Software Requirements Specification to ensure that 
  each of our modules aligned with the written requirements. For example - 


  \item \textbf{What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)}
  One limitation of our solution is that the performance of the AI model is constrained 
  by available computational resources and data for training the model. With access 
  to more powerful resources such as GPUs and greater storage capacity, we could train 
  more complex models which may perform better. Additionally, access to more data would allow 
  the model to learn better and improve accuracy when generating alternative text for images.

  \item \textbf{Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)}
  

  \item \textbf{(After you have implemented another team's module,
        which means this
      isn't filled in until after the original deadline). What did you learn by
      implementing another team's module? Were all the details you needed in the
      documentation, or did you need to make assumptions, or ask the other team
      questions?  If your team also had another team implement one of
      your modules,
      what was this experience like?  Are there things in your documentation you
      could have changed to make the process go more smoothly for when an
    ``outsider'' completes some of the implementation?}
\end{enumerate}



\end{document}
