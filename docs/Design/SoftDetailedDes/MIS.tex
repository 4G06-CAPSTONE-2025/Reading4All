\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts} 
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\newcommand{\String}{\mathsf{String}}
\newcommand{\Real}{\ensuremath{\mathbb{R}}}
\newcommand{\Bool}{\ensuremath{\mathbb{B}}}


\hypersetup{
  bookmarks=true,     % show bookmarks bar?
  colorlinks=true,       % false: boxed links; true: colored links
  linkcolor=red,          % color of internal links (change box color
  % with linkbordercolor)
  citecolor=blue,      % color of links to bibliography
  filecolor=magenta,  % color of file links
  urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{4cm}p{2cm}X}
  \toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
  \midrule
  November 13, 2025 & 1.0 &  Rev-1 Design Document\\
  January 11, 2025 & 1.1 & Peer Review \texttt{\#239} Applied\\
  \bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \citet{SRS}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for the
\progname{} system, \textbf{Reading4All}. Reading4All is an artificial intelligence (AI)/machine learning (ML) tool that
provides detailed and contextually aware alternative text for
complicated technical graphics, notably those found in postsecondary
Science, Technology, Engineering, and Mathematics (STEM) course materials.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/4G06-CAPSTONE-2025/Reading4All/}.

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname.

\begin{center}
  \renewcommand{\arraystretch}{1.2}
  \noindent
  \begin{tabular}{l l p{7.5cm}}
    \toprule
    \textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\
    \midrule
    character & char & a single symbol or digit\\
    integer & $\mathbb{Z}$ & a number without a fractional component
    in (-$\infty$, $\infty$) \\
    natural number & $\mathbb{N}$ & a number without a fractional
    component in [1, $\infty$) \\
    real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
    boolean & \Bool & True, False \\
    \bottomrule
  \end{tabular}
\end{center}

\noindent
The specification of \progname \ uses some derived data types:
sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document
for this project.
\begin{table}[h!]
  \centering
  \begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
    \toprule
    \textbf{Level 1} & \textbf{Level 2}\\
    \midrule

    {Hardware-Hiding Module} & N/A \\
    \midrule

    \multirow{13}{0.3\textwidth}{Behaviour-Hiding Module} &
    {DataPreprocess Module}\\ & 
    {WCAGCompliance Module}\\ &
    {ModelOutput Module}\\ &
    {AuthenticationService Module}\\ &
    {SessionManagement Module}\\ &
    {BackendController Module}\\ &
    {Logging Module}\\ &
    {ImageValidation Module}\\ & 
    {UserInterfaceInteractions Module} \\ & 
    {MainScreen Module} \\ &
    {ShowHistoryScreen Module} \\ &
    {LogInScreen Module} \\ &
    {UserInterfaceAccessibility Module} \\ 
    \midrule

    \multirow{6}{0.3\textwidth}{Software Decision Module} &
    {AIModelTraining Module }\\ &
    {CaptionGeneration Module}\\ &
    {InternalMetricCompliance}\\ &
    {FeedbackMetrics Module}\\ &
    {FeedbackLoop Module}\\ &
    {Feedback Module}\\
    \bottomrule
  \end{tabular}
  \caption{Module Hierarchy}
  \label{TblMH}
\end{table}

\newpage
~\newpage

%----------------------------------------------------------
\section{MIS of DataPreprocess Module} \label{datapp}

\subsection{Module}
\texttt{DataPP}

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{SUPPORTED\_IMAGE\_TYPES}: \texttt{List[String]} -- Accepted input formats (e.g., \{"PNG","JPEG"\}).\\
\texttt{TARGET\_WIDTH}: $\mathbb{N}$ -- Desired output width in pixels (may be hardcoded in early versions).\\
\texttt{TARGET\_HEIGHT}: $\mathbb{N}$ -- Desired output height in pixels (may be hardcoded in early versions).\\
\texttt{NORMALIZE\_MODE}: String -- Normalization scheme (e.g., \{"none","imagenet"\}); may be hardcoded.

\subsubsection{Exported Access Programs}
\begin{center}
  \begin{tabular}{p{2cm} p{4cm} p{6cm} p{4cm}}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  filterInput & imageFilePath:String & PreprocessedImagePath:String & InvalidInputException \\
  \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\texttt{lastInputPath}: String -- (Optional) caches most recently processed input path for debugging/traceability.\\
\texttt{lastOutputPath}: String -- (Optional) caches most recently produced output path for debugging/traceability.

\subsubsection{Environment Variables}
\texttt{Filesystem} -- Used to read input images and write preprocessed outputs.\\
\texttt{ImageCodec} -- System/library support for decoding/encoding image formats.

\subsubsection{Assumptions}
\begin{itemize}
  \item Constants may be hardcoded in the current implementation and moved to configuration later.
  \item State variables are optional; omitting them does not affect functional correctness.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{filterInput(imageFilePath):}
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item (Optional) \texttt{lastInputPath} := imageFilePath
    \item Verify that the file type is supported and the file is readable
    \item Apply resizing to (\texttt{TARGET\_WIDTH}, \texttt{TARGET\_HEIGHT}) and normalization according to \texttt{NORMALIZE\_MODE}
    \item Write the processed image to disk and produce \texttt{PreprocessedImagePath}
    \item (Optional) \texttt{lastOutputPath} := PreprocessedImagePath
  \end{itemize}
  \item output: Returns \texttt{PreprocessedImagePath} referencing the stored preprocessed image suitable for training and inference.
  \item exception: Raises \texttt{InvalidInputException} if the input is unsupported, unreadable, or corrupt.
\end{itemize}

\subsubsection{Local Functions}
None.

\section{MIS of WCAGCompliance Module} \label{wcagc}

\subsection{Module}
\texttt{WCAGComp}

\subsection{Uses}
Takes generated captions from the \texttt{CaptionGeneration} module and validates them against WCAG 2.1 AA criteria (\citet{WCAG}).

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{WCAG\_LEVEL}: String -- Target conformance level (e.g., \{"AA"\}); may be hardcoded.\\
\texttt{MIN\_CAPTION\_LEN}: $\mathbb{N}$ -- Minimum caption length (characters), may be hardcoded.\\
\texttt{MAX\_CAPTION\_LEN}: $\mathbb{N}$ -- Maximum caption length (characters), may be hardcoded.

\subsubsection{Exported Access Programs} 
\begin{center}
  \begin{tabular}{p{3cm} p{4cm} p{4cm} p{4cm}}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  checkCompliance & CaptionText:String & ComplianceReport:List & ValidationException \\
  \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\texttt{lastCheckedCaption}: String -- (Optional) caches the most recently validated caption for debugging/traceability.\\
\texttt{lastReport}: List -- (Optional) caches the most recently produced compliance report.

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
  \item Constants may be hardcoded in the current implementation and moved to configuration later.
  \item State variables are optional; omitting them does not affect functional correctness.
  \item Assumes the input caption text is available and properly formatted for validation.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{checkCompliance(CaptionText)}:
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item (Optional) \texttt{lastCheckedCaption} := CaptionText
    \item Validate basic WCAG-aligned constraints (e.g. length bounds using \texttt{MIN\_CAPTION\_LEN} and \texttt{MAX\_CAPTION\_LEN})
    \item Construct a \texttt{ComplianceReport} summarizing pass/fail, warnings, and violations
    \item (Optional) \texttt{lastReport} := ComplianceReport
  \end{itemize}
  \item output: Returns a \texttt{ComplianceReport} summarizing accessibility validation results.
  \item exception: Raises \texttt{ValidationException} if validation cannot be completed or the input is invalid.
\end{itemize}

\subsubsection{Local Functions}
None.

\section{MIS of ModelOutput Module} \label{modout}

\subsection{Module}
\texttt{ModOut}

\subsection{Uses}
Receives validated captions from the \texttt{WCAGCompliance} module or directly from the 
\texttt{CaptionGeneration} module when compliance checks are bypassed.  
Sends the final caption output to the user-facing interface or backend display component.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}


\begin{center}
  \begin{tabular}{p{3cm} p{3.5cm} p{4cm} p{4cm}}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  generateOutput & FinalCaption:String & DisplayConfirmation:\Bool & OutputException \\
  \hline
  \end{tabular}
  \end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.

\subsubsection{Environment Variables}
None.
\subsubsection{Assumptions}
\begin{itemize}
  \item Assumes the output channel (UI or backend) is active and ready to receive data.
\end{itemize}
  
\subsubsection{Access Routine Semantics}

\noindent \textbf{generateOutput(FinalCaption):}
\begin{itemize}
  \item transition: Sends the final caption text to the appropriate user-facing component for display.
  \item output: Returns \texttt{DisplayConfirmation} upon successful output delivery.
  \item exception: Raises \texttt{OutputException} if communication with the display component fails.
\end{itemize}

\subsubsection{Local Functions}
None.

%----------------------------------------------------------
\section{MIS of AIModelTraining Module} \label{aitrain}

\subsection{Module}
\texttt{AITrain}

\subsection{Uses}
Takes preprocessed data from the \texttt{DataPreprocess} module and trains a model that will later be used by the \texttt{CaptionGeneration} module for alt-text generation.

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{DEFAULT\_MODEL\_ID}: String -- Default model identifier/architecture used for training (may be hardcoded).\\
\texttt{MAX\_EPOCHS}: $\mathbb{N}$ -- Maximum number of training epochs (may be hardcoded).\\
\texttt{BATCH\_SIZE}: $\mathbb{N}$ -- Training batch size (may be hardcoded).\\
\texttt{LEARNING\_RATE}: \Real -- Default learning rate (may be hardcoded).\\
\texttt{CHECKPOINT\_DIR}: String -- Directory where checkpoints are written (may be hardcoded).\\
\texttt{CHECKPOINT\_FREQ}: $\mathbb{N}$ -- Save checkpoint every k steps/epochs (may be hardcoded).\\
\texttt{RANDOM\_SEED}: $\mathbb{N}$ -- Seed for reproducibility (optional; may be omitted in early versions).

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{3.5cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
initializeModel & configPath: String & - & ConfigFileNotFoundException \\
\hline
trainModel & trainingData: Dataset & trainedModel: Model & TrainingException \\
\hline
saveCheckpoint & progress: Integer & - & WriteErrorException \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\texttt{trainedModel}: Stores the trained model instance.

\subsubsection{Environment Variables}
\texttt{GPU/CPU} — used for training operations.\\
\texttt{Filesystem} — stores intermediate checkpoints and model outputs.

\subsubsection{Assumptions}
\begin{itemize}
  \item The input data is valid and preprocessed.
  \item The system has sufficient computational resources.
  \item The configuration file exists and can be accessed (may be a default/hardcoded configuration in early versions).
  \item Constants may be hardcoded in the current implementation and moved to configuration later.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{initializeModel(configPath):}
\begin{itemize}
  \item transition: Loads or initializes the model structure and related parameters based on \texttt{configPath} (or defaults).
  \item output: None.
  \item exception: Raises \texttt{ConfigFileNotFoundException} if the configuration is missing, unreadable, or invalid.
\end{itemize}

\noindent \textbf{trainModel(trainingData):}
\begin{itemize}
  \item transition: Trains the model on provided data and updates \texttt{trainedModel}.
  \item output: Returns the trained model.
  \item exception: Raises \texttt{TrainingException} if training fails due to invalid data, insufficient resources, or runtime errors.
\end{itemize}

\noindent \textbf{saveCheckpoint(progress):}
\begin{itemize}
  \item transition: Saves the model’s current state to \texttt{CHECKPOINT\_DIR} for recovery and future use.
  \item output: None.
  \item exception: Raises \texttt{WriteErrorException} if the checkpoint cannot be written (e.g., permission issues, missing directory, or I/O failure).
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
  \item \textbf{splitData(NewFilePath:String) \texttt{->} TestPath:String, TrainPath:String, ValPath:String}: Divides input data into training, validation, and testing portions.
\end{itemize}


%----------------------------------------------------------
\section{MIS of CaptionGeneration Module} \label{capgen}

\subsection{Module}
\texttt{CapGen}

\subsection{Uses}
Uses the trained model from the \texttt{AIModelTraining} module to generate descriptive alt-text for input images.

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{MAX\_CAPTION\_LEN}: $\mathbb{N}$ -- Maximum generated caption length (tokens/words) (may be hardcoded).\\
\texttt{MIN\_CAPTION\_LEN}: $\mathbb{N}$ -- Minimum caption length to avoid under-description (optional).\\
\texttt{DECODE\_STRATEGY}: String -- Decoding strategy (e.g., \{"greedy","beam"\}) (may be hardcoded).\\

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{3cm} p{3.5cm} p{4cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
loadModel & modelPath: String & - & ModelLoadException \\
\hline
generateCaption & image: Image & caption: String & GenerationException \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\texttt{loadedModel}: Stores the active trained model used for caption generation.

\subsubsection{Environment Variables}
\texttt{GPU/CPU} — executes model inference.

\subsubsection{Assumptions}
\begin{itemize}
  \item A valid trained model is available and compatible with the input format.
  \item Input images are properly preprocessed.
  \item Constants may be hardcoded in the current implementation and moved to configuration later.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{loadModel(modelPath)}:
\begin{itemize}
  \item transition: Loads the trained model from \texttt{modelPath} into memory as \texttt{loadedModel}.
  \item output: None.
  \item exception: Raises \texttt{ModelLoadException} if the model file is missing, unreadable, or incompatible.
\end{itemize}

\noindent \textbf{generateCaption(image)}:
\begin{itemize}
  \item transition: Uses \texttt{loadedModel} to generate a caption for \texttt{image} using \texttt{DECODE\_STRATEGY}.
  \item output: Returns generated alt-text for the input image.
  \item exception: Raises \texttt{GenerationException} if inference fails or a valid caption cannot be produced.
\end{itemize}

\subsubsection{Local Functions}
None.


\section{MIS of FeedbackMetrics Module} \label{modmetric}

\subsection{Module}
\texttt{ModMetric}

\subsection{Uses}
Receives generated captions from the \texttt{WCAGCompliance} module, evaluates their 
overall quality and accessibility, and sends the resulting performance scores to the 
\texttt{FeedbackIntegration} module for further model improvement.

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{SCORE\_RANGE}: Tuple -- Allowed score range (e.g. (0, 100)); may be hardcoded.\\
\texttt{PASS\_THRESHOLD}: $\mathbb{N}$ -- Minimum acceptable aggregate score; may be hardcoded.\\
\texttt{METRIC\_WEIGHTS}: Tuple -- (Optional) weighting factors for aggregate scoring; may be omitted in early versions.

\subsubsection{Exported Access Programs}
\begin{center}
  \begin{tabular}{p{3cm} p{3.5cm} p{4cm} p{4cm}}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    evaluateCaption & CaptionText:String & PerformanceScores:List & EvaluationException \\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\texttt{lastScores}: List -- (Optional) caches the most recently produced \texttt{PerformanceScores}.\\
\texttt{aggregateScore}: $\mathbb{Z}$ -- (Optional) most recent computed overall score.

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
  \item Constants may be hardcoded in the current implementation and moved to configuration later.
  \item State variables are optional; omitting them does not affect functional correctness.
  \item Assumes generated captions are available and that the chosen evaluation metrics are accessible.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{evaluateCaption(CaptionText)}:
\begin{itemize}
  \item transition:
  \begin{itemize}
    \item Compute performance indicators according to the selected metrics (may be a simplified scoring approach in early versions)
    \item (Optional) compute \texttt{aggregateScore} and clamp to \texttt{SCORE\_RANGE}
    \item (Optional) \texttt{lastScores} := PerformanceScores
  \end{itemize}
  \item output: Returns performance scores summarizing caption quality and accessibility 
  (see Appendix for Jing's evaluation metrics).
  \item exception: Raises \texttt{EvaluationException} if evaluation cannot be completed.
\end{itemize}

\subsubsection{Local Functions}
None.


\section{MIS of FeedbackIntegration Module} \label{modint}

\subsection{Module}
\texttt{ModInt}

\subsection{Uses}
Consumes performance scores from the \texttt{FeedbackMetrics} module and applies them to update model parameters 
in the \texttt{AIModelTraining} module, closing the feedback loop after inference.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
  \begin{tabular}{p{3cm} p{4cm} p{4cm} p{4cm}}
    \hline
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
    \hline
    updateModel & PerformanceScores:List & UpdateAck:\Bool & UpdateException \\
    \hline
  \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\texttt{modelState}: current model parameters selected for (re)training.

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
  \item Assumes valid performance scores are provided by the \texttt{FeedbackMetrics} module and that retraining 
  can be invoked in \texttt{AIModelTraining}.

\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{updateModel(PerformanceScores):}
\begin{itemize}
  \item transition: updates \texttt{modelState} and signals \texttt{AIModelTraining} to (re)train with revised parameters.
  \item output: returns \texttt{UpdateAck} confirming that the update request was accepted.
  \item exception: raises \texttt{UpdateException} if parameter update or retraining trigger fails.
\end{itemize}

\subsubsection{Local Functions}
None.


\section{MIS of BackendController Module} \label{Module} 


\subsection{Module}

\texttt{BackendController}

\subsection{Uses}
Serves as the coordinator between the frontend, backend and machine learning modules. 
\begin{itemize}
  \item Receives authentication and session status from the AuthenticationService Module (see Section~\ref{Module:AuthenticationService}) and SessionManagement module (see Section~\ref{Module:SessionManagement}), respectively.
  \item Sends uploaded images to the ImageValidation module (see Section~\ref{Module: ImageValid}) and receives validation results. 
  \item Sends validated inputs to the DataPreprocess module (see Section~\ref{datapp} )
  \item Sends errors and log events to the Logging module (see Section ~\ref{LogModule})
  \item Returns the generated alt text or error message to the MainScreen Module (see Section ~\ref{MainScreen}) 
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\texttt{SESSION\_TIMEOUT}: $\mathbb{N}$ - Specifies the amount of time in minutes a users logged-in session can remain active for before requiring reauthentication.\\ \\
\texttt{API\_RESPONSE\_TIMEOUT}: $\mathbb{N}$ - Specifies the amount of time in seconds that the controller waits for a response from other modules before timing out.\\

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{6cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
validateUser & userToken:String & userStatus:\Bool & InvalidTokenException \\
\hline
validateImage & imagePath:String, userToken: UUID & imagePath:\Bool & InvalidImageException\\
\hline
sendToModel & imagePath:String, userToken: UUID & - & AltTextGenerationError\\
\hline 
getAltText & imagePath:String, userToken: UUID & altText:String & AltTextNotFoundException\\
\hline 
returnToFrontend & altText or errorMsg: String, userID: UUID & - & UIUnreachableException \\
\hline
updateAltText & altText:String, userID:UUID & - & SessionStateSaveException\\
\hline 
init & fileDirectory:String &-& AccessError\\
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.

\subsubsection{Environment Variables}
\texttt{Filesystem} -  Used to access image data that is passed between coordinated modules.  

\subsubsection{Assumptions}

\begin{itemize}
  \item MainScreen, AuthenticationService, ImageValidation and DataPreprocess modules are correctly operating and reachable. 
  \item Network connection is available for API communication. 
  \item \texttt{init} will be called prior to any of the other exported access programs.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{validateUser(userToken)}:
\begin{itemize}
\item transition: Sends the \texttt{userToken} to the User Authentication Module for Verification.
\item output: Returns \texttt{True} if the user is valid, otherwise \texttt{False} is returned.
\item exception: \texttt{InvalidTokenException} is raised if token is expired or cannot be validated. 
\end{itemize}



\noindent \textbf{validateImage(image,userToken)}:
\begin{itemize}
\item transition: Sends the uploaded image and associated user token to the Image Validation Module for verification of file type and size.
\item output:  Returns \texttt{True} if the image was successfully validated, otherwise \texttt{False} is returned.
\item exception:  \texttt{InvalidImageException} is raised if the image fails the validation process and does not meet system requirements.
\end{itemize}



\noindent \textbf{sendToModel(image,userToken)}:
\begin{itemize}
\item transition: Sends the validated image and associated user token to the Machine Learning Module to initiate alt-text generation.  
\item output:  None.
\item exception: \texttt{AltTextGenerationError} is raised if the Machine Learning Module fails to process image or generate alt text. 
\end{itemize}


\noindent \textbf{returnToFrontend(alt Text or errorMsg, userToken)}:
\begin{itemize}
\item transition: Sends the generated alt text or corresponding error message to the Frontend Module. 
\item output:  None.
\item exception: \texttt{FrontendUnreachableException} is raised if the Frontend Module cannot be reached. 
\end{itemize}

\noindent \textbf{updateAltText(altText, userID)}:
\begin{itemize}
\item transition: Updates the user's existing alt-text generation to include their changes. 
\item output:  None
\item exception: \texttt{SessionStorageException} is raised if the system is unable to save the modified alt text to the users session history.
\end{itemize}

  \section{MIS of AuthenticationService Module} \label{Module:AuthenticationService}

  \subsection{Module}
  
  \texttt{AuthenticationService}
  
  \subsection{Uses}
  This module is responsible for managing and validating user authentication across the Reading4All system. It ensures that only verified users can upload, edit, or retrieve images and generated alt text.  
  \begin{itemize}
    \item LoginScreen Module: Receives user login and logout requests, sends authentication tokens.
    \item Session Management Module: Manages active sessions and stores validated tokens.
    \item Backend Controller Module: Requests user validation before allowing access to backend operations.
  \end{itemize}
  
  \subsection{Syntax}
  
  \subsubsection{Exported Constants}
  \texttt{TOKEN\_EXPIRY\_TIME}: $\mathbb{N}$ - Duration in minutes after which an authentication token expires. \\ \\
  \texttt{MAX\_LOGIN\_ATTEMPTS}: $\mathbb{N}$ - Maximum number of failed login attempts allowed before temporary account lockout. \\
  
  \subsubsection{Exported Access Programs}
  
  \begin{center}
  \begin{tabular}{p{3cm} p{4cm} p{3cm} p{4cm}} 
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  validateToken & userToken:String & Success:\Bool & InvalidTokenException \\
  \hline
  signInUser & credentials:String  & userToken:String & AuthenticationFailed-Exception \\
  \hline
  signOutUser & userToken:String & Success:\Bool & SessionNotFoundException \\
  \hline
  getCurrentUser & userToken:String & userID: String & UserNotAuthenticated-Exception \\
  \hline
  refreshToken & userToken:String & newToken:String & TokenRefreshException \\
  \hline
  \end{tabular}
  \end{center}
  \subsection{Semantics}
  
  \subsubsection{State Variables}
  \begin{itemize}
    \item \texttt{currentUser}: Stores information of the currently authenticated user (userID, role, status).
    \item \texttt{activeTokens}: List of active tokens issued during authenticated sessions.
  \end{itemize}
  
  \subsubsection{Environment Variables}
  \begin{itemize}
    \item  LoginAPI to authentication the information of users attempting to sign in.
  \end{itemize}
  
  \subsubsection{Assumptions}
  \begin{itemize}
    \item The database or session store used for token verification is operational.
    \item Network connection to backend and session services is stable.
    \item All tokens follow the system-defined structure and encryption standard.
  \end{itemize}
  
  \subsubsection{Access Routine Semantics}
  
  \noindent \textbf{validateToken(userToken)}:
  \begin{itemize}
  \item transition: Compares provided token against valid session records in \texttt{SessionManagement}.
  \item output: Returns \texttt{True} if token is valid and active, otherwise \texttt{False}.
  \item exception: \texttt{InvalidTokenException} is raised if the token has expired or does not exist.
  \end{itemize}
  
  \noindent \textbf{signInUser(credentials)}:
  \begin{itemize}
  \item transition: Verifies credentials (e.g., username and password) and issues a unique token for session creation.
  \item output: Returns a valid \texttt{userToken} on successful authentication.
  \item exception: \texttt{AuthenticationFailedException} is raised if credentials are invalid or user does not exist.
  \end{itemize}
  
  \noindent \textbf{signOutUser(userToken)}:
  \begin{itemize}
  \item transition: Removes the associated token from the active token list and ends the user’s session.
  \item output: Returns \texttt{True} on successful logout.
  \item exception: \texttt{SessionNotFoundException} is raised if the token is invalid or session not found.
  \end{itemize}
  
  \noindent \textbf{getCurrentUser(userToken)}:
  \begin{itemize}
  \item transition: Queries active sessions to identify the user associated with the token.
  \item output: Returns \texttt{userID} if token corresponds to an active session.
  \item exception: \texttt{UserNotAuthenticatedException} is raised if no active session exists for the token.
  \end{itemize}
  
  \noindent \textbf{refreshToken(userToken)}:
  \begin{itemize}
  \item transition: Reissues a new token with an updated expiry time after verifying the old token’s validity.
  \item output: Returns \texttt{newToken}.
  \item exception: \texttt{TokenRefreshException} is raised if old token is expired or tampered.
  \end{itemize}
  
  \subsubsection{Local Functions}
  \begin{itemize}
    \item \texttt{generateToken(userID)} — Creates a secure, encrypted token for the authenticated user.
    \item \texttt{encryptData(data)} — Encrypts sensitive authentication information before storage.
    \item \texttt{validateCredentials(credentials)} — Confirms user credentials against secure storage.
  \end{itemize}

  \section{MIS of SessionManagement Module} \label{Module:SessionManagement}

  \subsection{Module}
  \texttt{SessionManagement}
  
  \subsection{Uses}
  The Session Management module is responsible for creating, storing, and maintaining active user sessions within the Reading4All system. It also tracks the session-specific history of user interactions, referencing corresponding entries in the Reading4All data. Other modules, such as the Authentication Service and Backend Controller, rely on it for validating active tokens and retrieving user activity logs within the current session.
  \begin{itemize}
    \item \textbf{Authentication Service:} Initiates creation, validation, and deletion of sessions.
    \item \textbf{Backend Controller:} Updates session history after each major user action (e.g., validateImage, sendToModel, getAltText).
    \item \textbf{Reading4All Data:} Serves as the persistent storage layer for user images and generated alt-text records, referenced by session data IDs.
  \end{itemize}
  
  \subsection{Syntax}

  \subsubsection{Exported Constants}
  \texttt{MAX\_SESSION\_DURATION}: $\mathbb{N}$ - Specifies the maximum duration, in minutes, that a session remains active before expiration. \\ \\
  \texttt{SESSION\_REFRESH\_INTERVAL}: $\mathbb{N}$ - The interval, in minutes, at which session validity is checked or refreshed. \\ \\
  \texttt{MAX\_SESSION\_HISTORY}: $\mathbb{N}$ - Maximum number of interaction entries stored per session to prevent unbounded growth. \\
  
  \subsubsection{Exported Access Programs}
  
  \begin{center}
  \begin{tabular}{p{3.3cm} p{4.5cm} p{3.2cm} p{4cm}}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  createSession & userID:String & sessionToken:String & SessionCreation-Exception \\
  \hline
  storeSession & userID:String, sessionToken:String & success:\Bool & SessionStorageException \\
  \hline
  validateSession & userToken:String & success:\Bool & InvalidSessionException \\
  \hline
  deleteSession & userToken:String & success:\Bool & SessionNotFound-Exception \\
  \hline
  getSession & userToken:String & sessionData:String& SessionNotFound-Exception \\
  \hline
  appendInteraction & userToken:String, interactionEntry:String & success:\Bool & SessionNotFound-Exception \\
  \hline
  getSessionHistory & userToken:String, filter:String & interactionList:List & SessionNotFound-Exception \\
  \hline
  linkDataRecord & userToken:String, dataRecordID:String & success:\Bool & SessionNotFound-Exception \\
  \hline
  getRecentRecords & userToken:String, limit: $\mathbb{N}$ & dataRecordRefs:List & SessionNotFound-Exception \\
  \hline
  \end{tabular}
  \end{center}
  
  \subsection{Semantics}

  \subsubsection{State Variables}
  \begin{itemize}
      \item \texttt{activeSessions}: Mapping of \texttt{userID} $\rightarrow$ \texttt{sessionToken} representing currently active sessions.
      \item \texttt{sessionExpiry}: Mapping of \texttt{sessionToken} $\rightarrow$ expiry time.
      \item \texttt{sessionHistory}: Mapping of \texttt{sessionToken} $\rightarrow$ ordered list of interaction entries for that session.
      \item \texttt{sessionDataRefs}: Mapping of \texttt{sessionToken} $\rightarrow$ set of dataRecordIDs referencing Reading4All data entries.
  \end{itemize}
  
  \subsubsection{Environment Variables}
  \begin{itemize}
      \item \texttt{SystemClock}: Provides current time for session expiry calculations.
      \item \texttt{StorageService}: Fast-access storage for session and interaction data.
      \item \texttt{Browser}: Storing session tokens for the valid duration of user activity.
  \end{itemize}
  
  \subsubsection{Assumptions}
  \begin{itemize}
      \item The system clock is synchronized to ensure accurate session expiry times.
      \item Tokens and user IDs are unique and securely generated.
      \item A fast-access storage service (e.g., in-memory cache or Redis) is available for storing session and interaction data.
      \item Reading4All data provides stable and retrievable \texttt{dataRecordID}s for cross-module referencing.
  \end{itemize}
  
  \subsubsection{Access Routine Semantics}
  
  \noindent \textbf{createSession(userID)}:
  \begin{itemize}
      \item transition: Generates a new session token, initializes empty history and data references, and sets the expiry time.
      \item output: Returns the created \texttt{sessionToken}.
      \item exception: Raises \texttt{SessionCreationException} if session creation fails.
  \end{itemize}
  
  \noindent \textbf{validateSession(userToken)}:
  \begin{itemize}
      \item transition: None.
      \item output: Returns \texttt{True} if the session exists and is active, otherwise \texttt{False}.
      \item exception: Raises \texttt{InvalidSessionException} if the token is expired or invalid.
  \end{itemize}
  
  \noindent \textbf{appendInteraction(userToken, interactionEntry)}:
  \begin{itemize}
      \item transition: Appends the provided \texttt{interactionEntry} (with timestamp and type) to \texttt{sessionHistory[userToken]}. If the maximum history size is exceeded, the oldest entry is removed.
      \item output: Returns \texttt{True} upon success.
      \item exception: Raises \texttt{SessionNotFoundException} if the token is not associated with an active session.
  \end{itemize}
  
  \noindent \textbf{linkDataRecord(userToken, dataRecordID)}:
  \begin{itemize}
      \item transition: Associates the provided \texttt{dataRecordID} (from Reading4All data) with the user’s current session for future retrieval.
      \item output: Returns \texttt{True} upon success.
      \item exception: Raises \texttt{SessionNotFoundException} if no active session exists.
  \end{itemize}
  
  \noindent \textbf{getSessionHistory(userToken, filter)}:
  \begin{itemize}
      \item transition: None.
      \item output: Returns a filtered list of interaction entries (e.g., uploads, alt-text retrieval) for the specified session.
      \item exception: Raises \texttt{SessionNotFoundException} if the token is invalid or no session history exists.
  \end{itemize}
  
  \noindent \textbf{getRecentRecords(userToken, limit)}:
  \begin{itemize}
      \item transition: None.
      \item output: Returns up to the specified number of recent \texttt{dataRecordID} references associated with the current session.
      \item exception: Raises \texttt{SessionNotFoundException} if no active session exists.
  \end{itemize}
  
  \noindent \textbf{deleteSession(userToken)}:
  \begin{itemize}
      \item transition: Removes the token from active sessions and clears its associated history and data references.
      \item output: Returns \texttt{True} if deletion is successful.
      \item exception: Raises \texttt{SessionNotFoundException} if the token is invalid or not found.
  \end{itemize}
  
  \subsubsection{Local Functions}
  \begin{itemize}
      \item \textbf{generateSessionToken(userID)}: Creates a secure, unique token for the given user.
      \item \textbf{updateExpiry(sessionToken)}: Extends the expiry time of a session on continued activity.
      \item \textbf{cleanExpiredSessions()}: Removes all expired sessions and their histories from storage.
      \item \textbf{applyHistoryFilter(history, filter)}: Applies filtering parameters (e.g., type, time range, status) to session history queries.
  \end{itemize}

\section{MIS of ImageValidation Module} \label{Module: ImageValid}

\subsection{Module}
  \texttt{ImageValidation}

\subsection{Uses}
None.
\subsection{Syntax}

\subsubsection{Exported Constants}
  \texttt{MAX\_IMAGE\_SIZE}: $\mathbb{N}$ - Specifies the maximum file size in (MB) allowed for uploaded images.\\
  \texttt{MIN\_IMAGE\_SIZE}: $\mathbb{N}$ - Specifies the minimum file size in (MB) allowed for uploaded images.\\
  \texttt{ACCEPTED\_IMAGE\_TYPES}: \texttt{List of Strings}- Specifies the accepted image file types. 
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4 cm} p{5cm} p{3 cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
validateImageFile & imagePath:String, userToken:String & imageStatus: \(\mathbb{B}\)& InvalidImageType-Exception \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.

\subsubsection{Environment Variables}
\texttt{Filesystem} - Used to retrieve images using the file path provided by users.



\subsubsection{Assumptions}

  \begin{itemize}
  \item The \texttt{BackendController} module provides the ImageValidation module with an image file that is reachable for validation. 
  \item The user has successfully been validated through the user authentication process. 
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent \textbf{validateImageFile(imagePath, userToken)}
\begin{itemize}
\item transition: Verifies that the inputted image meets size and format requirements.
\item output: Returns \texttt{True} if the image meets size and format requirements, otherwise \texttt{False} is returned.
\item exception: \texttt{InvalidImageException} is raised if the image cannot be reached and therefore cannot be validated. 
\end{itemize}


\subsubsection{Local Functions}
\begin{itemize}
  \item \textbf{verifyFileType(imagePath)}: Checks that the images file type matches a type found in \texttt{ACCEPTED\_IMAGE\_TYPES}.
  \item \textbf{verifyFileSize(imagePath)}: Checks that the images size falls between \texttt{MIN\_IMAGE\_SIZE} and \texttt{MAX\_IMAGE\_SIZE}.
  \item \textbf{verifyFileReachable(imagePath)}: Checks that the image can be accessed and opened successfully. 
\end{itemize}


\section{MIS of Logger Module} \label{LogModule} 

\subsection{Module}
\texttt{Logger}

\subsection{Uses}
The module handles the recording of key system events and any errors encountered. It logs actions such as image uploads, alt-text generation and user validations, as well as system issues like timeouts. This logging will enables developers to debug for effectively and ensure system reliability and security during failures. 
The logging module does not use any other modules. 

\subsection{Syntax}

\subsubsection{Exported Constants}
  \texttt{LOG\_FILE\_PATH}: String - Specifies the location of where the logs should be stored.\\
  \texttt{LOG\_TYPE}: List of Strings - Specifies the possible log types such as an \texttt{Event} and \texttt{Error}.\\

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{7cm} p{3cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
logEvent & eventMssg:String, logType:String & - & LogWriteException\\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}
\texttt{Filesystem} - Used to save the log files to the specified path.

\subsubsection{Assumptions}
\begin{itemize}
  \item The file system is available and logs can be saved to it. 
  \item The LOG\_FILE\_PATH location can be accessed. 
  \item Log messages are provided in string format by the Backend Controller Module.
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent \textbf{logEvent(eventMssg, logType)}:
\begin{itemize}
\item transition: Creates an log entry containing the time of event occur, type and message. 
\item output: An updated log file with new event or error entry added. 
\item exception: \texttt{LogWriteException} is raised if the log file cannot be accessed or written to. 
\end{itemize}

\subsubsection{Local Functions}

None.


\section{MIS of UserInterfaceInteractions Module}\label{UI_Interactions}

\subsection{Module}

\texttt{InteractionsUI}

\subsection{Uses}
This module uses \texttt{BackendController} to authenticate the users that are signing in, and to obtain the 
generated alternative text. It also uses the display modules (\texttt{MainScreen}, \texttt{LogInScreen},
\texttt{ShowHistoryScreen}) to render the different screens and interfaces to the users. 

\subsection{Syntax}

\subsubsection{Exported Constants}

\texttt{SUPPORTED\_IMG\_TYPES = \{"PNG", "JPEG"\}}\\
\texttt{OUTPUT\_FILE\_TYPE = \{".txt"\}}\\
\texttt{MAX\_IMG\_SIZE = 10MB}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2.5cm} p{4cm} p{4cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
uploadImage & imageFilePath:String & Success:\Bool & FileNotFound, FileTypeNotSupported, FileTooLarge\\
\hline
downloadText & altText:String & altTextFile:String & NetworkError \\
\hline
copyText & altText:String & Success:\Bool & ClipboardError \\
\hline
editText & altText:String, editedText:String & Success:\Bool & NetworkError \\
\hline
signIn & token:String & Success:\(\mathbb{B}\) & AuthError \\
\hline
signOut & - & Success:\(\mathbb{B}\) & AuthError \\
\hline
showHistory & - & Success:\(\mathbb{B}\) & NetworkError \\

\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

\begin{itemize}
  \item \texttt{Clipboard} - system's clipboard interface for copy function.
  \item \texttt{HTTPClient} - used to call backend services.
  \item \texttt{Keyboard} - provides key press events that trigger corresponding UI action handlers such as sign in and upload image. 
  \item \texttt{FileSystem} - used to access file paths. 
\end{itemize}


\subsubsection{Assumptions}
  
  \begin{itemize}
    \item \texttt{Clipboard} access is enabled by the user for \texttt{copyText}.
    \item User allows system to access files for uploading images and downloading alt text. 
    \item \texttt{uploadImage} is called before any other access program.
    \item Each exported access program represents an event handler that is invoked in response to user-triggered actions such as mouse clicks and keyboard presses on the user interface.
  \end{itemize}


\subsubsection{Access Routine Semantics}

\noindent \textbf{uploadImage(imageFilePath)}:
\begin{itemize}
\item transition: \texttt{HTTPClient} sends the image bytes into the backend service which stores the image for that session, and communicates 
with the AI model for alt text generation. 
\item output: returns \texttt{true} iff the backend server acknowledges and is able to process the image, returns \texttt{false} otherwise.
\item exception: \texttt{FileNotFound}, \texttt{FileTypeNotSupported} (not in \texttt{SUPPORT\_IMG\_TYPES}), 
and \texttt{FileTooLarge} (not within \texttt{MAX\_IMG\_SIZE})
\end{itemize}

\noindent \textbf{downloadText(altText)}:
\begin{itemize}
\item transition: None.
\item output: a \texttt{.txt} payload that contains the generated alt text. 
\item exception: \texttt{NetworkError}.
\end{itemize}

\noindent \textbf{copyText(altText)}:
\begin{itemize} 
\item transition: \texttt{Clipboard} := altText
\item output: returns \texttt{true} iff clipboard write succeeds, returns \texttt{false} otherwise. 
\item exception: \texttt{ClipboardError}.
\end{itemize}

\noindent \textbf{editText(altText,editedText)}:
\begin{itemize}
\item transition: \texttt{HTTPClient} sends update to backend and stored altText for uploaded image is replaced with editedText.
\item output: return \texttt{true} iff server acknowledges the update, returns \texttt{false} otherwise.
\item exception: \texttt{NetworkError}.
\end{itemize}

\noindent \textbf{signIn(token)}:
\begin{itemize}
\item transition: if \texttt{token} is valid according to BackendController then user session becomes active.
Otherwise no state change.
\item output: return \texttt{true} iff user session is active, returns \texttt{false} otherwise.
\item exception: \texttt{AuthenticationError}.
\end{itemize}

\noindent \textbf{signOut()}:
\begin{itemize}
\item transition: terminates current active user session if any exists.
Otherwise no state change.
\item output: return \texttt{true} iff user session is was terminated, returns \texttt{false} otherwise.
\item exception: \texttt{AuthenticationError}.
\end{itemize}

\noindent \textbf{showHistory()}:
\begin{itemize}
\item transition: requests the ShowHistoryScreen module to render the History Screen using the current stored alt text session history.
\item output: return \texttt{true} iff history was successfully shown, returns \texttt{false} otherwise.
\item exception: \texttt{AuthenticationError}.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \textbf{isSupportedImage(filePath:String) \texttt{->} \Bool}: returns \texttt{true} if 
  the file type $\in$ \texttt{SUPPORTED\_IMG\_TYPES}.
  \item \textbf{checkImgSize(filePath:String) \texttt{->} \Bool}: returns \texttt{true} if 
  the size of the image $\le$ \texttt{MAX\_IMG\_SIZE}.
  \item \textbf{saveAsTxt(altText: String) \texttt{->} filePath:String}: wraps generated alt text
   into a \texttt{.txt} file for \texttt{downloadText()}.
  \item \textbf{buildUploadPayload(filePath: String) \texttt{->} Binary}: reads the file and constructs the binary payload for the 
  \texttt{uploadImage} function to send to the BackendController module.
\end{itemize}


\section{MIS of MainScreen Module}\label{MainScreen} 

\subsection{Module}

\texttt{MainScreen}

\subsection{Uses}
This module uses \texttt{AccessibilityUI} to ensure that the content within the interface is 
compatible with screen readers and tabbable by a keyboard.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2.5cm} p{4cm} p{4cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
renderMain & - & - & RenderError, AccessibilityError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

\texttt{DOM} - active document element into which UI is rendered.

\subsubsection{Assumptions}

\begin{itemize}
  \item Accessibility services are provided by the \texttt{AccessibilityUI} module for screen reader announcements,
  landmark management, initial focus, and keyboard navigation helpers. This module will provide notifications to
  the \texttt{AccessibilityUI} module. 
\end{itemize}
\subsubsection{Access Routine Semantics}

\noindent \textbf{renderMain()}:
\begin{itemize}
  \item transition: update DOM to reflect main screen containing the upload page, then call on \texttt{AccessibilityUI} to 
  handle compatibility with screen readers and keyboard navigation.
  \item output: None.
  \item exception: \texttt{RenderError}, \texttt{AccessibilityError}.
\end{itemize}


\subsubsection{Local Functions}

\begin{itemize}
  \item \textbf{ensureMainLandmark()  \texttt{->} \Bool}: calls \texttt{AccessibilityUI}
  to mark/set the main landmark.
  \item \textbf{setInitialFocus()\texttt{->} \Bool}: calls \texttt{AccessibilityUI}
   to move focus to the main region.
  \item \textbf{announceMainLoaded() \texttt{->} \Bool}: calls \texttt{AccessibilityUI}
   to announce screen load.

\end{itemize}

\section{MIS of ShowHistoryScreen Module}\label{showHistory} 

\subsection{Module}

\texttt{ShowHistoryScreen}

\subsection{Uses}

This module uses \texttt{AccessibilityUI} to ensure that the content within the interface is 
compatible with screen readers and tabbable by a keyboard.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2.5cm} p{4cm} p{4cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
showHistory & - & - & RenderError, AccessibilityError\\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

\texttt{DOM} - active document element into which UI is rendered.

\subsubsection{Assumptions}

\begin{itemize}
  \item If history is shown, a valid and authenticated session already exists.
  \item \texttt{AccessibilityUI} is used for announcements and focus.
  \item History content to display is already prepared by the \texttt{InteractionsUI} module through
  the \texttt{BackendController} module.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \textbf{showHistory()}:
\begin{itemize} 
  \item transition: update DOM to reflect user's current session history, then call on \texttt{AccessibilityUI} to 
  handle compatibility with screen readers and keyboard navigation.
  \item output: None.
  \item exception: \texttt{RenderError}, \texttt{AccessibilityError}.
\end{itemize}

\subsubsection{Local Functions}

\begin{itemize}
  \item \textbf{ensureMainLandmark()  \texttt{->} \Bool}: calls \texttt{AccessibilityUI}
  to mark/set the main landmark.
  \item \textbf{setInitialFocus()\texttt{->} \Bool}: calls \texttt{AccessibilityUI}
   to move focus to the main region.
  \item \textbf{announceHistoryLoaded() \texttt{->} \Bool}: calls \texttt{AccessibilityUI}
   to announce history screen load.
\end{itemize}

\section{MIS of LogInScreen Module}\label{LogInScreen} 


\subsection{Module}

\texttt{LogInScreen}

\subsection{Uses}

This module uses \texttt{AccessibilityUI} to ensure that the content within the interface is 
compatible with screen readers and tabbable by a keyboard.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2.5cm} p{3cm} p{3cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
renderLogIn & - & - & RenderError, AccessibilityError \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

\texttt{DOM} - active document element into which UI is rendered.

\subsubsection{Assumptions}

\begin{itemize}
  \item \texttt{AccessibilityUI} is used for announcements and focus.
\end{itemize}

\subsubsection{Access Routine Semantics}


\noindent \textbf{renderLogIn()}:
\begin{itemize}
\item transition: update \texttt{DOM} to reflect log in screen with username and password fields, 
then call on \texttt{AccessibilityUI} to 
handle compatibility with screen readers and keyboard navigation.
\item output: None.
\item exception: \texttt{RenderError}, \texttt{AuthenticationError}.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
  \item \textbf{ensureMainLandmark()  \texttt{->} \Bool}: calls \texttt{AccessibilityUI}
  to mark/set the main landmark.
  \item \textbf{setInitialFocus(username:String)\texttt{ -> }\Bool}:
  calls \texttt{accessibilityUI} to move keyboard focus to the username
  input field after the log in screen is rendered.
  \item \textbf{announceLogInLoaded() \texttt{->} \Bool}: calls \texttt{AccessibilityUI}
   to announce log in screen load.
\end{itemize}

\section{MIS of UserInterfaceAccessibility Module}\label{UI_accessibility}
  
  \subsection{Module}
  
  \texttt{AccessibilityUI}
  
  \subsection{Uses}
 
  This module uses the display modules (\texttt{MainScreen}, \texttt{LogInScreen},
  \texttt{showHistorScreeny}) to receive notifications of user activity to announce changes 
  through a screen reader and apply keyboard navigation to the content in those screens. 
  \subsection{Syntax}
  
  \subsubsection{Exported Constants}
  
  \subsubsection{Exported Access Programs}
  
  \begin{center}
  \begin{tabular}{p{4cm} p{4cm} p{3cm} p{3cm}}
  \hline
  \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
  \hline
  ensureMainLandmark & rootSel:String & Success:\(\mathbb{B}\) & AccessibilityError\\
  setInitialFocus & targetSel:String & Success:\(\mathbb{B}\) & AccessibilityError\\
  announce & msg:String & Success:\(\mathbb{B}\) & AccessibilityError\\
  applyKeyboardNav & scopeSel:String & Success:\(\mathbb{B}\) & AccessibilityError\\
  \hline
  \end{tabular}
  \end{center}
  
  \subsection{Semantics}
  
  \subsubsection{State Variables}

  None.
  
  \subsubsection{Environment Variables}
    \texttt{DOM} - the active HTML document containing interactive elements \\ 
    \texttt{ScreenReaderAPI} - hidden live region nodes used to deliver announcements to screen readers 
    for compatibility\\
    \texttt{Keyboard} - delivers keypress events to use for keyboard navigation\\
  
  \subsubsection{Assumptions}

    \begin{itemize}
      \item The page allows insertion of valid ARIA (\citet{ARIA}) live region nodes
      \item \texttt{MainScreen}, \texttt{LogInScreen}, \texttt{ShowHistoryScreen} modules calls \texttt{AccessibilityUI} 
      to announce changes on the user interface. 
    \end{itemize}
  
  \subsubsection{Access Routine Semantics}
  
  \noindent \textbf{ensureMainLandmark(rootSel:String)}:
  \begin{itemize}
  \item transition: ensure that the element selected by \texttt{rootSel} is the page’s 
  main landmark (i.e. \texttt{<main>}).
  \item output: returns \texttt{true} if main landmark was present after the call, returns \texttt{false}
  otherwise.
  \item exception: \texttt{AccessibilityError}.
  \end{itemize}  

  \noindent \textbf{setInitialFocus(targetSel:String)}:
  \begin{itemize}
  \item transition: move keyboard focus to the element matching \texttt{targetSel} for keyboard navigation; 
  if not focusable, make it focusable for the interaction.
  \item output: returns \texttt{true} if focus was moved, returns \texttt{false}
  otherwise.
  \item exception: \texttt{AccessibilityError}.
  \end{itemize}

  \noindent \textbf{announce(msg:String)}:
  \begin{itemize}
  \item transition: update the ARIA (\citet{ARIA}) live region with \texttt{msg} 
  so screen readers can announce the change.
  \item output: returns \texttt{true} if live region was updated, returns \texttt{false}
  otherwise.
  \item exception: \texttt{AccessibilityError}.
  \end{itemize}

  \noindent \textbf{applyKeyboardNav(scopeSel:String)}:
  \begin{itemize}
  \item transition: attach handlers within \texttt{scopeSel} (container that gets arrow-key navigation behaviour) 
  to enable roving-tabindex and arrow-key navigation (i.e., ArrowLeft/Right/Up/Down, Home/End, Enter/Space activation) 
  without changing application state.
  \item output: returns \texttt{true} if handlers are attached successfully, returns \texttt{false}
  otherwise.
  \item exception: \texttt{AccessibilityError}.
  \end{itemize}
  
  
  \subsubsection{Local Functions}
  \begin{itemize}
    \item \textbf{getLiveRegion(type:String)  \texttt{->} Node}: returns the hidden live region for announcements;
    calls on \texttt{createLiveRegion(type: String)} if no live region to create one.
    \item \textbf{createLiveRegion(type:String) \texttt{->} Node}: creates and returns the hidden live region for announcements.
    \item \textbf{isFocusable(node:Node) \texttt{ -> }\Bool}: returns \texttt{true} if \texttt{node} is focusable. 
    \item \textbf{applyRovingTabindex(container:Node) \texttt{->} \Bool}: ensures exactly one child is tabbable 
    and others are reachable via arrow keys.
    \item \textbf{moveFocus(container:Node, dir:String) \texttt{->} \Bool}: shifts focus to the next or previous roving 
    item given \texttt{dir} $\in$ \texttt{{ "next","prev","home","end" }}.
  \end{itemize}


\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable?
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
  \item Which of your design decisions stemmed from speaking to your client(s)
    or a proxy (e.g. your peers, stakeholders, potential users)? For those that
    were not, why, and where did they come from?
  \item While creating the design doc, what parts of your other documents (e.g.
    requirements, hazard analysis, etc), it any, needed to be changed, and why?
  \item What are the limitations of your solution?  Put another way, given
    unlimited resources, what could you do to make the project
    better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
    are the benefits and tradeoffs of those other designs compared
    with the chosen
    design?  From all the potential options, why did you select the
    documented design?
    (LO\_Explores)
\end{enumerate}


\end{document} 
